# 合成断句代码逻辑总结

## 一、概述

"合成断句"功能是系统的核心功能之一，负责将文本断句通过华为云TTS服务合成为音频文件。整个流程采用异步消息队列（RocketMQ）架构，支持限流控制和状态管理。

## 二、核心组件架构

### 2.1 组件层次结构

```
Controller层 (SynthesisController)
    ↓
Service层 (SynthesisService/SynthesisServiceImpl)
    ↓
消息队列层 (RocketMQ)
    ├── TTS合成请求队列 (TtsSynthesisConsumer)
    └── TTS回调消息队列 (TtsCallbackConsumer)
    ↓
华为云TTS API
    ↓
回调处理 (handleTtsCallback)
    ↓
OBS存储 (ObsStorageService)
```

### 2.2 主要类文件

| 类名 | 路径 | 职责 |
|------|------|------|
| `SynthesisController` | `controller/SynthesisController.java` | 提供HTTP接口入口 |
| `SynthesisService` | `service/SynthesisService.java` | 合成服务接口 |
| `SynthesisServiceImpl` | `service/impl/SynthesisServiceImpl.java` | 合成服务实现（核心逻辑） |
| `RocketMQTtsSynthesisService` | `service/RocketMQTtsSynthesisService.java` | 发送合成请求到消息队列 |
| `TtsSynthesisConsumer` | `consumer/TtsSynthesisConsumer.java` | 消费合成请求，调用华为云API（限流5次/秒） |
| `RocketMQTtsCallbackService` | `service/RocketMQTtsCallbackService.java` | 发送回调消息到消息队列 |
| `TtsCallbackConsumer` | `consumer/TtsCallbackConsumer.java` | 消费回调消息，处理合成结果 |
| `SsmlRenderer` | `util/SsmlRenderer.java` | 生成SSML格式文本 |
| `SynthesisStatusUtil` | `util/SynthesisStatusUtil.java` | 合成状态聚合工具 |

## 三、数据库表结构

### 3.1 核心表

#### breaking_sentences（断句表）
- `breaking_sentence_id`: 断句ID（主键）
- `task_id`: 任务ID
- `original_sentence_id`: 原始拆句ID
- `content`: 断句内容
- `char_count`: 字符数
- `sequence`: 序号
- `ssml`: SSML格式文本（用于TTS合成）
- `synthesis_status`: 合成状态（0-未合成，1-合成中，2-已完成，3-失败）
- `audio_url`: 音频文件URL（OBS地址）
- `audio_duration`: 音频时长（毫秒）
- `job_id`: 华为云TTS任务ID

#### synthesis_settings（合成设置表）
- `breaking_sentence_id`: 断句ID（外键）
- `voice_id`: 音色ID
- `speech_rate`: 语速（0-200，100为正常）
- `volume`: 音量（0-200，140为默认）
- `pitch`: 音调（-100到100，0为默认）

#### pause_settings（停顿设置表）
- `breaking_sentence_id`: 断句ID
- `position`: 位置
- `duration`: 时长
- `type`: 类型（1-停顿，2-静音）

#### polyphonic_settings（多音字设置表）
- `breaking_sentence_id`: 断句ID
- `word`: 字符
- `position`: 位置
- `pronunciation`: 发音

#### prosody_settings（韵律设置表）
- `breaking_sentence_id`: 断句ID
- `begin_position`: 开始位置
- `end_position`: 结束位置
- `rate`: 语速

## 四、核心流程详解

### 4.1 合成断句主流程

#### 4.1.1 接口入口
**路径**: `POST /api/synthesis/breakingSentence`

**Controller方法**: `SynthesisController.synthesizeBreakingSentence()`
```java
@PostMapping("/breakingSentence")
public ApiResponse<String> synthesizeBreakingSentence(
        @RequestBody SynthesisBreakingSentenceRequest request)
```

#### 4.1.2 服务层处理
**方法**: `SynthesisServiceImpl.synthesize(Long breakingSentenceId)`

**流程步骤**:

1. **参数验证**
   - 验证 `breakingSentenceId` 不为空

2. **查询断句信息**
   - 从 `breaking_sentences` 表查询断句
   - 验证断句是否存在
   - 验证 SSML 是否存在

3. **读取合成参数**
   - 从 `synthesis_settings` 表读取参数（voiceId、speechRate、volume、pitch）
   - 如果参数为0或null，设置默认值：
     - `volume`: 默认140
     - `speechRate`: 默认100
     - `voiceId`: 默认 "c41f12c125f24c834ed3ae7c1fdae456"
     - `pitch`: 默认0
   - 将默认值更新到数据库

4. **构建TTS合成请求**
   ```java
   TtsSynthesisRequest synthesisRequest = new TtsSynthesisRequest();
   synthesisRequest.setBreakingSentenceId(breakingSentenceId);
   synthesisRequest.setVoiceId(voiceId);
   synthesisRequest.setSpeechRate(speechRate);
   synthesisRequest.setVolume(volume);
   synthesisRequest.setPitch(pitch);
   synthesisRequest.setSsml(sentence.getSsml());  // 使用SSML字段
   ```

5. **发送到消息队列**
   - 调用 `RocketMQTtsSynthesisService.sendSynthesisRequest()`
   - 将请求发送到RocketMQ的TTS合成主题
   - 如果发送失败，更新状态为失败并返回

6. **更新状态**
   - 更新 `breaking_sentences.synthesis_status = 1`（合成中）

7. **返回结果**
   - 成功：返回 "合成中"
   - 失败：返回 "合成失败"

### 4.2 消息队列消费流程

#### 4.2.1 TTS合成请求消费者
**类**: `TtsSynthesisConsumer`

**限流机制**:
- 使用 `ScheduledExecutorService` 定时处理
- 每200毫秒处理一条消息（5次/秒）
- 使用 `BlockingQueue` 缓存消息

**处理流程**:

1. **接收消息**
   - 从RocketMQ消费消息
   - 解析为 `TtsSynthesisRequest` 对象

2. **调用华为云API**
   ```java
   CreateAsyncTtsJobRequest ttsRequest = new CreateAsyncTtsJobRequest();
   CreateAsyncTtsJobRequestBody body = new CreateAsyncTtsJobRequestBody();
   body.withText(request.getSsml())  // 使用SSML
       .withVoiceAssetId(request.getVoiceId())
       .withSpeed(request.getSpeechRate())
       .withVolume(request.getVolume())
       .withCallbackConfig(new TtsCallBackConfig().withCallbackUrl(callbackUrl));
   ```

3. **保存job_id**
   - 将华为云返回的 `jobId` 保存到 `breaking_sentences.job_id`
   - 更新状态为合成中（status=1）

4. **异常处理**
   - 连接异常、超时异常、服务异常等都会更新状态为失败（status=3）

### 4.3 回调处理流程

#### 4.3.1 回调接口
**路径**: `POST /api/synthesis/callback`

**Controller方法**: `SynthesisController.handleTtsCallback()`
- 接收华为云TTS回调
- 将回调请求发送到RocketMQ消息队列（异步处理）

#### 4.3.2 回调消息消费者
**类**: `TtsCallbackConsumer`

**处理流程**:
1. 从RocketMQ消费回调消息
2. 调用 `SynthesisService.handleTtsCallback()` 处理

#### 4.3.3 回调业务处理
**方法**: `SynthesisServiceImpl.handleTtsCallback()`

**流程**:

1. **查找断句**
   - 根据 `jobId` 从数据库查找对应的 `breaking_sentence_id`

2. **根据状态处理**
   - **FINISHED（完成）**: 调用 `handleFinishedCallback()`
   - **ERROR（失败）**: 调用 `handleErrorCallback()`
   - **WAITING（等待）**: 记录日志，不处理

#### 4.3.4 完成回调处理
**方法**: `SynthesisServiceImpl.handleFinishedCallback()`

**详细流程**:

1. **验证音频URL**
   - 检查回调中的 `audioFileDownloadUrl` 是否存在

2. **下载音频文件**
   - 从华为云下载URL下载音频文件到本地临时目录
   - 本地路径：`temp/audio/breaking_{breakingSentenceId}_{timestamp}.wav`
   - 使用 `downloadFileToLocal()` 方法

3. **上传到OBS**
   - 调用 `ObsStorageService.uploadFromFile()` 上传到华为云OBS
   - 生成OBS对象键：`audio/breaking_{breakingSentenceId}_{timestamp}.wav`
   - 获取OBS URL

4. **更新数据库**
   - 更新 `breaking_sentences` 表：
     - `synthesis_status = 2`（已完成）
     - `audio_url = obsUrl`
     - `audio_duration = duration * 1000`（秒转毫秒）

5. **更新任务状态**
   - 调用 `updateTaskStatusIfNeeded()` 更新任务状态

6. **清理临时文件**
   - 删除本地临时文件

#### 4.3.5 失败回调处理
**方法**: `SynthesisServiceImpl.handleErrorCallback()`

**流程**:
- 更新 `breaking_sentences.synthesis_status = 3`（失败）
- 更新任务状态

### 4.4 任务状态更新逻辑

**方法**: `SynthesisServiceImpl.updateTaskStatusIfNeeded()`

**规则**:
1. 查询任务下所有断句
2. 统计各状态数量：
   - `completed`: 状态为2（已完成）
   - `failed`: 状态为3（失败）
   - `processing`: 状态为1（合成中）
   - `pending`: 状态为0（未合成）
3. 根据优先级更新任务状态：
   - **优先级1（失败）**: 如果有失败的断句 → `SYNTHESIS_FAILED`
   - **优先级2（进行中）**: 如果有进行中或待处理的断句 → `SYNTHESIS_PROCESSING`
   - **优先级3（成功）**: 如果全部完成 → `SYNTHESIS_SUCCESS`

## 五、SSML生成逻辑

### 5.1 SSML生成时机

在 `setConfig()` 方法中，当更新断句配置后，会重新生成SSML：

```java
String ssml = SsmlRenderer.renderFromConfig(ssmlConfig);
breakingSentenceMapper.updateSsml(breakingSentenceId, ssml);
```

### 5.2 SSML生成方法

**类**: `SsmlRenderer`

**方法**: `renderFromConfig(BreakingSentenceConfig config)`

**支持的标签**:
1. **break标签**: 停顿和静音
   - 从 `breakList` 和 `silenceList` 生成
   - 格式：`<break time="500ms"/>`

2. **phoneme标签**: 多音字
   - 从 `phonemeList` 生成
   - 格式：`<phoneme alphabet="py" ph="zhong1">中</phoneme>`

3. **prosody标签**: 韵律（语速）
   - 从 `prosodyList` 生成
   - 支持范围设置（begin-end）
   - 格式：`<prosody rate="120%">文本</prosody>`

4. **voice标签**: 音色
   - 从 `voiceId` 生成
   - 格式：`<voice name="voiceId">`

5. **prosody标签（全局）**: 语速、音量、音调
   - 从 `speed`、`volume` 生成
   - 格式：`<prosody rate="100%" volume="140dB">`

### 5.3 SSML结构示例

```xml
<speak>
  <voice name="c41f12c125f24c834ed3ae7c1fdae456">
    <prosody rate="100%" volume="140dB">
      文本内容
      <break time="500ms"/>
      <phoneme alphabet="py" ph="zhong1">中</phoneme>
      <prosody rate="120%">快速文本</prosody>
    </prosody>
  </voice>
</speak>
```

## 六、批量合成功能

### 6.1 合成拆句
**接口**: `POST /api/synthesis/originalSentence`

**方法**: `SynthesisServiceImpl.synthesizeOriginalSentence()`

**流程**:
1. 查询拆句下的所有断句
2. 遍历每个断句，调用 `synthesize()` 方法
3. 收集失败信息
4. 返回结果（如果有失败，返回失败详情）

### 6.2 合成任务
**接口**: `POST /api/synthesis/task`

**方法**: `SynthesisServiceImpl.synthesizeTask()`

**流程**:
1. 验证任务是否存在
2. 查询任务下的所有断句
3. 遍历每个断句，调用 `synthesize()` 方法
4. 收集失败信息
5. 返回结果

## 七、状态查询功能

### 7.1 获取断句合成状态
**接口**: `GET /api/synthesis/getBreakingSentenceStatus`

**方法**: `SynthesisServiceImpl.getBreakingSentenceStatus()`

**返回**:
- `audioUrl`: 音频URL
- `audioDuration`: 音频时长（毫秒）
- `synthesisStatus`: 合成状态（0/1/2/3）

### 7.2 获取拆句合成状态
**接口**: `GET /api/synthesis/getOriginalSentenceStatus`

**方法**: `SynthesisServiceImpl.getOriginalSentenceStatus()`

**返回**:
- `status`: 聚合状态
- `progress`: 进度（0-100）
- `total`: 总断句数
- `completed`: 已完成数
- `pending`: 待处理数
- `audioUrlList`: 音频URL列表（按sequence排序）

### 7.3 获取任务合成状态
**接口**: `GET /api/synthesis/getTaskStatus`

**方法**: `SynthesisServiceImpl.getTaskStatus()`

**返回**: 同拆句合成状态

### 7.4 状态聚合逻辑
**工具类**: `SynthesisStatusUtil.aggregateSynthesisStatus()`

**聚合规则**（优先级从高到低）:
1. 如果任一断句状态为3（失败） → 返回3（失败）
2. 如果所有断句状态都是2（已完成） → 返回2（已完成）
3. 如果任一断句状态为1（合成中）或2（已合成） → 返回1（进行中）
4. 默认 → 返回0（未合成）

## 八、配置设置功能

### 8.1 设置合成参数
**接口**: `POST /api/synthesis/setConfig`

**方法**: `SynthesisServiceImpl.setConfig()`

**功能**:
1. **更新断句内容**
   - 更新 `breaking_sentences.content`
   - 更新 `char_count`

2. **更新合成设置**
   - 更新 `synthesis_settings` 表（voiceId、speed、volume）

3. **更新停顿设置**
   - 删除旧的 `pause_settings` 记录
   - 插入新的记录（breakList和silenceList）

4. **更新多音字设置**
   - 删除旧的 `polyphonic_settings` 记录
   - 插入新的记录（phonemeList）

5. **更新韵律设置**
   - 删除旧的 `prosody_settings` 记录
   - 插入新的记录（prosodyList）

6. **更新阅读规则**
   - 删除旧的 `reading_rule_applications` 记录
   - 插入新的记录（readRule）

7. **重新生成SSML**
   - 调用 `SsmlRenderer.renderFromConfig()` 生成新的SSML
   - 更新 `breaking_sentences.ssml`

## 九、关键配置参数

### 9.1 应用配置（application.properties）

```properties
# 华为云配置
huaweicloud.ak=xxx
huaweicloud.sk=xxx
huaweicloud.region=cn-north-4
huaweicloud.project-id=xxx
huaweicloud.obs.endpoint=xxx
huaweicloud.obs.bucket=xxx
huaweicloud.obs.prefix=audio/

# 本地存储路径
file.storage.local.path=temp/audio

# 回调URL
app.callback.url=http://your-domain/api/synthesis/callback

# RocketMQ配置
rocketmq.tts.topic=tts-topic
rocketmq.tts.callback.topic=tts-callback-topic
```

### 9.2 默认值

- **默认音色ID**: `c41f12c125f24c834ed3ae7c1fdae456`
- **默认音量**: `140`
- **默认语速**: `100`
- **默认音调**: `0`
- **限流速率**: `5次/秒`（每200毫秒处理一次）

## 十、异常处理

### 10.1 合成请求阶段异常
- 断句不存在 → 更新状态为失败
- SSML为空 → 更新状态为失败
- 消息队列发送失败 → 更新状态为失败

### 10.2 华为云API调用异常
- 连接异常 → 更新状态为失败
- 请求超时 → 更新状态为失败
- 服务响应异常 → 更新状态为失败

### 10.3 回调处理异常
- 音频URL为空 → 更新状态为失败
- 文件下载失败 → 更新状态为失败
- OBS上传失败 → 更新状态为失败
- 所有异常都会更新任务状态

## 十一、数据流转图

```
用户请求
  ↓
SynthesisController
  ↓
SynthesisServiceImpl.synthesize()
  ↓
RocketMQ (TTS合成请求队列)
  ↓
TtsSynthesisConsumer (限流5次/秒)
  ↓
华为云TTS API (创建异步任务)
  ↓
华为云处理
  ↓
回调 → SynthesisController.handleTtsCallback()
  ↓
RocketMQ (TTS回调队列)
  ↓
TtsCallbackConsumer
  ↓
SynthesisServiceImpl.handleTtsCallback()
  ↓
下载音频 → 上传OBS → 更新数据库
  ↓
更新任务状态
```

## 十二、关键设计点

### 12.1 异步消息队列架构
- 使用RocketMQ解耦合成请求和实际API调用
- 支持限流控制（5次/秒）
- 提高系统吞吐量和稳定性

### 12.2 状态管理
- 断句状态：0-未合成，1-合成中，2-已完成，3-失败
- 任务状态：根据断句状态聚合
- 状态更新时机：请求发送、API调用、回调处理

### 12.3 SSML格式
- 使用SSML统一管理所有合成参数
- 支持停顿、多音字、韵律等高级功能
- 在配置更新时自动重新生成

### 12.4 文件存储
- 临时文件存储在本地（temp/audio）
- 最终文件存储在华为云OBS
- 处理完成后自动清理临时文件

### 12.5 错误处理
- 所有异常都会更新状态为失败
- 记录详细日志便于排查
- 不影响其他断句的合成

## 十三、总结

"合成断句"功能是一个完整的异步TTS合成系统，主要特点：

1. **异步处理**: 使用消息队列实现异步合成，提高响应速度
2. **限流控制**: 通过消息队列和定时任务实现5次/秒的限流
3. **状态管理**: 完善的状态流转和聚合机制
4. **SSML支持**: 支持丰富的SSML标签，实现精细化的语音控制
5. **容错机制**: 完善的异常处理和状态更新机制
6. **批量处理**: 支持单个、拆句、任务三个层级的合成

整个系统设计合理，具有良好的扩展性和可维护性。
