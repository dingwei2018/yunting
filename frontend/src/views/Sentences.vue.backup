.sentence-row {
  margin-bottom: 12px;
}

<template>
  <div class="sentences-page">
    <div class="page-header">
      <h2>éŸ³é¢‘ç²¾ä¿®</h2>
      <div class="header-actions">
        <el-button 
          type="primary" 
          @click="handleSynthesizeAll" 
          :loading="synthesizingAll"
          :disabled="!canSynthesizeAll"
        >
          åˆæˆå…¨éƒ¨éŸ³é¢‘
        </el-button>
        <el-button 
          type="primary" 
          @click="handleMergeAudio" 
          :loading="merging"
          :disabled="!canMergeAudio"
        >
          åˆå¹¶éŸ³é¢‘
        </el-button>
      </div>
    </div>

    <el-card v-loading="loading" class="sentences-card">
      <div v-if="sentences.length === 0 && !loading" class="empty-state">
        <el-empty description="æš‚æ— å¥å­æ•°æ®" />
      </div>

      <div v-else class="sentence-list" @scroll="handleScroll">
        <div
          v-for="(sentence, index) in rootSentences"
          :key="sentence.sentence_id"
          class="sentence-item"
        >
          <div class="sentence-layout">
            <div class="sentence-main">
              <div class="sentence-header">
                <span class="sentence-number">æ‹†å¥{{ index + 1 }}</span>
                <span class="sentence-duration" v-if="sentence.duration">
                  {{ formatDuration(sentence.duration) }}
                </span>
              </div>

              <div class="sentence-row">
                <div class="sentence-content">
                  <div class="sentence-text-row">
                    <div class="sentence-text">
                      {{ getCombinedSentenceContentReactive(sentence) }}
                    </div>
                    <div class="sentence-links">
                      <SentenceActionLinks
                        :audio-url="sentence.audio_url"
                        :synthesis-status="getOriginalSentenceSynthesisStatus(sentence.sentence_id)"
                        :show-insert-after="false"
                        @play="handlePlayOriginalSentence(sentence)"
                        @synthesize="handleResynthesizeOriginalSentence(sentence.sentence_id)"
                        @delete="handleDelete(sentence.sentence_id)"
                      />
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div class="sentence-quick-actions">
              <el-button link type="primary" @click="toggleEdit(sentence)">
                {{ editingSentenceId === sentence.sentence_id ? 'æ”¶èµ·ç²¾ä¿®' : 'ç¼–è¾‘' }}
              </el-button>
            </div>
          </div>

          <transition name="fade">
            <div
              v-if="editingSentenceId === sentence.sentence_id"
              class="editing-panel"
            >
              <SentenceTuningPanel
                :voice-categories="voiceCategories"
                :voice-options="voiceOptions"
                :active-voice-category="activeVoiceCategory"
                :custom-options="customOptions"
                :editing-form="editingForm"
                :custom-disabled="customDisabledState"
                :active-actions="activeCustomActions"
                :selection-context="currentSelectionContext"
                @update:activeVoiceCategory="handleUpdateCategory"
                @select-voice="selectVoice"
                @custom-action="handleCustomAction"
                @request-local-speed="handleRequestLocalSpeed"
                @clear-text="() => handleClearText(sentence)"
                @synthesize-all="handleSynthesizeAllBreakingSentences"
              />

              <SubSentenceEditorList
                :subs="getBreakingSentencesFromApi(sentence.sentence_id)"
                :editing-sub-sentence-id="editingSubSentenceId"
                :get-polyphonic-markers="getPolyphonicMarkers"
                :is-polyphonic-mode-active="isPolyphonicModeActive"
                :set-editor-ref="setEditorRef"
                :get-breaking-sentence-status="getBreakingSentenceSynthesisStatus"
                @select-sub="selectSubSentence"
                @editor-selection-change="({ sub, payload }) => handleEditorSelectionChange(sub, payload)"
                @editor-content-change="(sub) => handleEditorContentChange(sub)"
                @polyphonic-hover="({ sub, payload }) => handlePolyphonicHover(sub, payload)"
                @editor-focus="(sub) => handleEditorFocus(sub)"
                @speed-segments-change="handleSpeedSegmentsChange"
                @play="handlePlay"
                @synthesize="handleResynthesizeBreakingSentence"
                @insert-after="handleInsertAfter"
                @delete="handleDelete"
              />
              <div class="textarea-actions">
                <div class="textarea-buttons">
                  <el-button @click="closeEditing">å–æ¶ˆ</el-button>
                  <el-button type="primary" @click="handleSaveCurrent">
                    ä¿å­˜å½“å‰ä¿®æ”¹
                  </el-button>
                </div>
              </div>
            </div>
          </transition>

          <!-- éŸ³é¢‘æ’­æ”¾å™¨ -->
          <audio
            v-if="sentence.audio_url"
            :ref="el => setAudioRef(sentence.sentence_id, el)"
            :src="sentence.audio_url"
            preload="none"
          />
        </div>
      </div>
    </el-card>
    
    <!-- åˆ†é¡µçŠ¶æ€æç¤º - ç½®äºé¡µé¢æœ€ä¸‹ç«¯ -->
    <div v-if="loadingMore" class="loading-more">
      <el-icon class="is-loading"><Loading /></el-icon>
      <span>åŠ è½½ä¸­...</span>
    </div>
    <div v-else-if="!hasMore && sentences.length > 0" class="no-more">
      æ²¡æœ‰æ›´å¤šæ•°æ®äº†
    </div>

    <transition name="fade">
      <PolyphonicTooltip
        v-if="polyphonicTooltip.visible"
        :visible="polyphonicTooltip.visible"
        :position="polyphonicTooltip.position"
        :char="polyphonicTooltip.char"
        :options="polyphonicTooltip.options"
        :selected="polyphonicTooltip.selected"
        @mouseenter="handleTooltipMouseEnter"
        @mouseleave="handleTooltipMouseLeave"
        @select="handlePolyphonicOptionSelect"
      />
    </transition>

    <!-- merge-footer å·²éšè— -->
    <!-- <div class="merge-footer" style="display: none;">
      <el-button type="primary" size="large" @click="handleSynthesizeAll" :loading="synthesizingAll">
        åˆæˆå…¨éƒ¨éŸ³é¢‘
      </el-button>
      <el-button type="primary" size="large" @click="handleMergeAudio" :loading="merging">
        åˆå¹¶éŸ³é¢‘
      </el-button>
    </div> -->

    <SplitStandardDialog
      :visible="splitStandardDialogVisible"
      :type="splitStandardType"
      :char-count="splitStandardCharCount"
      @update:visible="(val) => (splitStandardDialogVisible = val)"
      @update:type="(val) => (splitStandardType = val)"
      @update:char-count="(val) => (splitStandardCharCount = val)"
      @confirm="handleSplitStandardConfirm"
      @close="handleSplitStandardDialogClose"
    />

    <el-dialog
      v-model="localSpeedDialog.visible"
      title="å±€éƒ¨è¯­é€Ÿè°ƒæ•´"
      width="420px"
      :close-on-click-modal="false"
    >
      <div class="local-speed-dialog__body">
        <div class="local-speed-dialog__info">
          å·²é€‰å­—ç¬¦ï¼š{{ localSpeedDialog.rangeLength }} ä¸ª
        </div>
        <el-slider
          v-model="localSpeedDialog.value"
          :min="-10"
          :max="10"
          :step="1"
          show-input
        />
      </div>
      <template #footer>
        <el-button @click="handleCancelLocalSpeed">å– æ¶ˆ</el-button>
        <el-button type="primary" @click="handleConfirmLocalSpeed">ç¡® å®š</el-button>
      </template>
    </el-dialog>

    <!-- åˆæˆè¿›åº¦å¯¹è¯æ¡† -->
    <el-dialog
      v-model="taskSynthesisProgress.visible"
      title="åˆæˆè¿›åº¦"
      width="500px"
      :close-on-click-modal="false"
      :close-on-press-escape="false"
      :show-close="false"
      class="synthesis-progress-dialog"
    >
      <div class="progress-content">
        <div class="progress-header">
          <h3>æ­£åœ¨åˆæˆå…¨éƒ¨éŸ³é¢‘</h3>
        </div>
        <div class="progress-info">
          <el-progress
            :percentage="taskSynthesisProgress.progress"
            :status="taskSynthesisProgress.status === 'completed' ? 'success' : taskSynthesisProgress.status === 'failed' ? 'exception' : undefined"
            :stroke-width="8"
          />
          <div class="progress-text">
            <span>å·²å®Œæˆï¼š{{ taskSynthesisProgress.completed }} / {{ taskSynthesisProgress.total }}</span>
            <span v-if="taskSynthesisProgress.pending > 0">å¾…å¤„ç†ï¼š{{ taskSynthesisProgress.pending }}</span>
          </div>
          <div class="progress-status">
            <span v-if="taskSynthesisProgress.status === 'processing'">åˆæˆä¸­ï¼Œè¯·ç¨å€™...</span>
            <span v-else-if="taskSynthesisProgress.status === 'completed'" class="success">åˆæˆå®Œæˆï¼</span>
            <span v-else-if="taskSynthesisProgress.status === 'failed'" class="error">åˆæˆå¤±è´¥</span>
          </div>
        </div>
      </div>
    </el-dialog>
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount, reactive, computed, watch, h, defineComponent, defineOptions, inject } from 'vue'

defineOptions({
  name: 'Sentences'
})
import { useRoute, useRouter } from 'vue-router'
import { ElMessage, ElMessageBox, ElRadioGroup, ElRadio, ElDialog, ElInput, ElProgress } from 'element-plus'
import { Loading } from '@element-plus/icons-vue'
import { polyphonic } from 'pinyin-pro'
import SentenceTuningPanel from '@/components/SentenceTuningPanel.vue'
import SentenceActionLinks from '@/components/SentenceActionLinks.vue'
import SubSentenceEditorList from '@/components/SubSentenceEditorList.vue'
import SplitStandardDialog from '@/components/SplitStandardDialog.vue'
import PolyphonicTooltip from '@/components/PolyphonicTooltip.vue'
import { useSentencesRepository } from '@/composables/useSentencesRepository'
import { convertBreakingSentenceToApi, createSubSentence, parsePauseMarkersFromContent } from '@/models/sentenceModels'
import { synthesizeOriginalSentence, getOriginalSentenceStatus, synthesizeBreakingSentence, getBreakingSentenceStatus, setConfig, synthesizeTask, getTaskStatus } from '@/api/synthesis'
import { getTaskDetail } from '@/api/task'
import { SentenceController } from '@/controllers/sentenceController'

const route = useRoute()
const router = useRouter()
const sentencesRepository = useSentencesRepository()

// æ³¨å…¥å…¨å±€éŸ³é¢‘æ’­æ”¾å™¨
const audioPlayer = inject('audioPlayer', null)
const {
  loading,
  merging,
  sentences,
  taskId,
  hasMore,
  loadingMore,
  loadSentences,
  loadMoreSentences,
  handleMergeAudio: mergeAudioTask,
  insertAfter: insertSentenceAfterLocal,
  deleteSentence: deleteSentenceApi,
  synthesizeSentence: synthesizeSentenceApi,
  getSentence: getSentenceApi,
  updateSentence: updateSentenceApi
} = sentencesRepository

// ç”¨äºå­˜å‚¨æ–­å¥æ ‡å‡†é€‰æ‹©çš„å€¼
const splitStandardType = ref('punctuation')
const splitStandardCharCount = ref(50) // é»˜è®¤å­—ç¬¦æ•°
const splitStandardDialogVisible = ref(false)
const splitStandardContext = ref(null) // å­˜å‚¨å½“å‰æ“ä½œçš„ä¸Šä¸‹æ–‡
const audioRefs = ref({})
const editingSentenceId = ref(null)
const editingSubSentenceId = ref(null)
const pendingSelectSubSentenceId = ref(null)

// æ‹†å¥åˆæˆçŠ¶æ€ç®¡ç†
const originalSentenceStatus = ref({}) // { [originalSentenceId]: { status, audioUrlList, timer } }
// æ–­å¥åˆæˆçŠ¶æ€ç®¡ç†
const breakingSentenceStatus = ref({}) // { [breakingSentenceId]: { status, audioUrl, timer } }
// å½“å‰æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘ä¿¡æ¯
const currentPlayingAudio = ref(null) // { sentenceId, audioList, currentIndex, audioElements }
// åˆæˆå…¨éƒ¨éŸ³é¢‘çš„åŠ è½½çŠ¶æ€
const synthesizingAll = ref(false)
// ä»»åŠ¡çŠ¶æ€
const taskStatus = ref(null) // 0-æ‹†å¥å®Œæˆï¼Œ1-è¯­éŸ³åˆæˆä¸­ï¼Œ2-è¯­éŸ³åˆæˆæˆåŠŸï¼Œ3-è¯­éŸ³åˆæˆå¤±è´¥ï¼Œ4-è¯­éŸ³åˆå¹¶ä¸­ï¼Œ5-è¯­éŸ³åˆå¹¶æˆåŠŸï¼Œ6-è¯­éŸ³åˆå¹¶å¤±è´¥
const taskMergeId = ref(null) // åˆå¹¶IDï¼Œç”¨äºè·³è½¬
// ä»»åŠ¡åˆæˆè¿›åº¦é®ç½©çŠ¶æ€
const taskSynthesisProgress = ref({
  visible: false,
  status: '', // 'processing', 'completed', 'failed'
  progress: 0, // 0-100
  total: 0,
  completed: 0,
  pending: 0,
  timer: null
})
// ä¿å­˜åŸå§‹æ‹†å¥åˆ—è¡¨æ•°æ®ï¼Œç”¨äºè·å– synthesisStatus
const originalSentenceListData = ref(null) // ä¿å­˜ getOriginalSentenceList è¿”å›çš„åŸå§‹æ•°æ®
// ä¿å­˜æ•°æ®å¤‡ä»½ï¼Œç”¨äºå–æ¶ˆæ—¶æ¢å¤
const backupSentences = ref(null) // ä¿å­˜ sentences çš„æ·±æ‹·è´å¤‡ä»½
const backupOriginalSentenceListData = ref(null) // ä¿å­˜ originalSentenceListData çš„æ·±æ‹·è´å¤‡ä»½

const editingForm = reactive({
  sentenceId: '',
  content: '',
  voice: 'default',
  volume: 70,
  speed: 0,
  pitch: 50
})

const clampVolume = (value) => {
  if (typeof value !== 'number' || Number.isNaN(value)) return 70
  return Math.min(100, Math.max(0, Math.round(value)))
}

const clampSpeed = (value) => {
  if (typeof value !== 'number' || Number.isNaN(value)) return 0
  return Math.min(10, Math.max(-10, Math.round(value)))
}

const editorRefs = reactive({})
const pauseEligibilityMap = reactive({})
const selectionStateMap = reactive({})
const polyphonicModeMap = reactive({})
const polyphonicStateMap = reactive({})
const polyphonicTooltip = reactive({
  visible: false,
  sentenceId: null,
  markerId: '',
  char: '',
  options: [],
  selected: '',
  position: { x: 0, y: 0 }
})
let polyphonicTooltipTimer = null
const isTooltipHovering = ref(false)

const findSentenceById = (id) => {
  if (id == null) return null
  // ä½¿ç”¨ == è€Œä¸æ˜¯ ===ï¼Œä»¥å¤„ç†å­—ç¬¦ä¸²å’Œæ•°å­—çš„åŒ¹é…
  return sentences.value.find((item) => item.sentence_id == id || String(item.sentence_id) === String(id))
}

// ç»Ÿä¸€çš„ ID ç”Ÿæˆå™¨ï¼šä¸ºæ–°å¢çš„æ–­å¥ç”Ÿæˆå”¯ä¸€çš„è´Ÿæ•° IDï¼ˆ-1, -2, -3...ï¼‰
// ç¡®ä¿æ–°å¢ ID çš„å”¯ä¸€æ€§ï¼Œæ’åºåªä¾èµ–äº display_orderï¼Œä¸ä¾èµ–äº ID
const generateNewSentenceId = () => {
  // æ‰¾åˆ°æ‰€æœ‰è´Ÿæ•° IDï¼ˆæ–°å¢çš„æ–­å¥ï¼‰
  const existingNegativeIds = sentences.value
    .filter(item => typeof item.sentence_id === 'number' && item.sentence_id < 0)
    .map(item => item.sentence_id)
  
  // å¦‚æœæ²¡æœ‰ä»»ä½•è´Ÿæ•° IDï¼Œä» -1 å¼€å§‹
  if (existingNegativeIds.length === 0) {
    return -1
  }
  
  // æ‰¾åˆ°æœ€å°çš„è´Ÿæ•° IDï¼ˆæœ€æ¥è¿‘ 0 çš„è´Ÿæ•°ï¼‰
  const minNegativeId = Math.min(...existingNegativeIds)
  
  // è¿”å›æ¯”æœ€å°è´Ÿæ•° ID å° 1 çš„ IDï¼ˆæ›´å°çš„è´Ÿæ•°ï¼‰
  return minNegativeId - 1
}

// åˆ›å»ºå¥å­æ§åˆ¶å™¨å®ä¾‹
// sentenceController å°†åœ¨æ‰€æœ‰ä¾èµ–å‡½æ•°å®šä¹‰ååˆå§‹åŒ–
let sentenceController = null

const currentSubSentence = computed(() =>
  findSentenceById(editingSubSentenceId.value)
)

const isPauseEnabled = computed(() =>
  editingSubSentenceId.value
    ? !!pauseEligibilityMap[editingSubSentenceId.value]
    : false
)

const customDisabledState = computed(() => ({
  pause: !isPauseEnabled.value
}))

const activeCustomActions = computed(() => ({
  polyphonic: editingSubSentenceId.value
    ? !!polyphonicModeMap[editingSubSentenceId.value]
    : false
}))

const rootSentences = computed(() =>
  sentences.value.filter((item) => !item.parent_id || item.parent_id === 0)
)

const getSubSentences = (parentId) => {
  const parent = findSentenceById(parentId)
  if (!parent) return []
  const children = sentences.value
    .filter((item) => item.parent_id === parentId)
    .sort((a, b) => (a.display_order || 0) - (b.display_order || 0))
  return [parent, ...children]
}

// ä»æ¥å£æ•°æ®ä¸­è·å–æ–­å¥åˆ—è¡¨ï¼ˆç”¨äºç¼–è¾‘æ—¶æ˜¾ç¤ºï¼Œä½¿ç”¨æ¥å£çš„ breakingSentence æ•°æ®ï¼‰
const getBreakingSentencesFromApi = (originalSentenceId) => {
  // åªåœ¨å¼€å‘ç¯å¢ƒä¸”å¼€å¯è°ƒè¯•æ—¶è¾“å‡ºæ—¥å¿—
  const shouldLog = process.env.NODE_ENV === 'development' && window.DEBUG_BREAKING_SENTENCES === true
  
  if (shouldLog) {
    console.log('ğŸ“‹ [getBreakingSentencesFromApi] ä»æ¥å£æ•°æ®è·å–æ–­å¥åˆ—è¡¨', {
      originalSentenceId,
      hasOriginalData: !!originalSentenceListData.value
    })
  }
  
  // ä»åŸå§‹æ¥å£æ•°æ®ä¸­æŸ¥æ‰¾
  const listData = originalSentenceListData.value
  const sentenceList = listData?.list || listData?.data?.list
  
  if (!sentenceList || !Array.isArray(sentenceList)) {
    if (shouldLog) {
      console.warn('âš ï¸ [getBreakingSentencesFromApi] æ²¡æœ‰åŸå§‹æ•°æ®ï¼Œå›é€€åˆ°æœ¬åœ°æ•°æ®')
    }
    // å¦‚æœæ²¡æœ‰åŸå§‹æ•°æ®ï¼Œå›é€€åˆ°æœ¬åœ°æ•°æ®
    return getSubSentences(originalSentenceId).filter(sub => sub.parent_id !== 0)
  }
  
  // æŸ¥æ‰¾å¯¹åº”çš„æ‹†å¥
  const originalSentence = sentenceList.find(
    os => os.originalSentenceId == originalSentenceId || String(os.originalSentenceId) === String(originalSentenceId)
  )
  
  if (!originalSentence || !Array.isArray(originalSentence.breakingSentenceList)) {
    if (shouldLog) {
      console.warn('âš ï¸ [getBreakingSentencesFromApi] æœªæ‰¾åˆ°æ‹†å¥æˆ–æ–­å¥åˆ—è¡¨ï¼Œå›é€€åˆ°æœ¬åœ°æ•°æ®', {
        originalSentenceId,
        foundOriginalSentence: !!originalSentence
      })
    }
    return getSubSentences(originalSentenceId).filter(sub => sub.parent_id !== 0)
  }
  
  // å°†æ¥å£çš„ breakingSentenceList è½¬æ¢ä¸ºå‰ç«¯æ ¼å¼
  const breakingSentences = originalSentence.breakingSentenceList.map((breakingSentence) => {
    // ä» sentences ä¸­æŸ¥æ‰¾å¯¹åº”çš„æœ¬åœ°æ•°æ®ï¼ˆå¯èƒ½åŒ…å«æœ¬åœ°ä¿®æ”¹ï¼Œå¦‚ content çš„å®æ—¶ç¼–è¾‘ï¼‰
    const localSentence = sentences.value.find(
      s => s.sentence_id == breakingSentence.breakingSentenceId || 
           String(s.sentence_id) === String(breakingSentence.breakingSentenceId)
    )
    
    // ä½¿ç”¨ controller çš„æ–¹æ³•è½¬æ¢æ¥å£æ•°æ®
    return sentenceController.convertBreakingSentenceFromApi(
      breakingSentence,
      originalSentenceId,
      localSentence
    )
  }).sort((a, b) => (a.display_order || 0) - (b.display_order || 0))
  
  // å…³é”®ä¿®å¤ï¼šæ·»åŠ æœ¬åœ°æ–°æ’å…¥çš„æ–­å¥ï¼ˆID ä¸º -1ï¼‰
  // ä» sentences.value ä¸­æŸ¥æ‰¾æ‰€æœ‰ parent_id === originalSentenceId ä¸” ID ä¸º -1 çš„æ–­å¥
  console.log('ğŸ” [getBreakingSentencesFromApi] è¿‡æ»¤æœ¬åœ°æ–­å¥å‰', {
    originalSentenceId,
    sentencesValue: sentences.value
      .filter(s => s.parent_id === originalSentenceId)
      .map(s => ({
        sentence_id: s.sentence_id,
        parent_id: s.parent_id,
        content: s.content,
        display_order: s.display_order,
        indexInArray: sentences.value.findIndex(item => item.sentence_id === s.sentence_id)
      }))
  })

  const localBreakingSentences = sentences.value
    .filter(s => {
      // å¿…é¡»æ˜¯æ–­å¥ï¼ˆparent_id !== 0ï¼‰
      if (!s.parent_id || s.parent_id === 0) return false
      // parent_id å¿…é¡»ç­‰äºæ‹†å¥ID
      if (s.parent_id !== originalSentenceId) return false
      // ID å¿…é¡»ä¸ºè´Ÿæ•°ï¼ˆæ–°æ’å…¥çš„æ–­å¥ï¼Œä½¿ç”¨è´Ÿæ•°ä½œä¸ºä¸´æ—¶IDï¼Œå¦‚ -1, -2, -3...ï¼‰
      const isNewSentence = typeof s.sentence_id === 'number' && s.sentence_id < 0
      // æ£€æŸ¥æ˜¯å¦å·²ç»åœ¨æ¥å£æ•°æ®ä¸­ï¼ˆé¿å…é‡å¤ï¼‰
      const existsInApi = originalSentence.breakingSentenceList.some(
        bs => bs.breakingSentenceId == s.sentence_id || String(bs.breakingSentenceId) === String(s.sentence_id)
      )
      // åªåŒ…å«æœ¬åœ°æ–°æ’å…¥çš„æ–­å¥ï¼ˆID ä¸ºè´Ÿæ•°ä¸”ä¸åœ¨æ¥å£æ•°æ®ä¸­ï¼‰
      return isNewSentence && !existsInApi
    })
    .map(localSentence => ({
      ...localSentence,
      // ç¡®ä¿ parent_id æ­£ç¡®
      parent_id: originalSentenceId,
      // ç¡®ä¿ display_order æœ‰å€¼
      display_order: localSentence.display_order ?? 0
    }))

  console.log('ğŸ” [getBreakingSentencesFromApi] è¿‡æ»¤æœ¬åœ°æ–­å¥å', {
    localBreakingSentences: localBreakingSentences.map(s => ({
      sentence_id: s.sentence_id,
      content: s.content,
      display_order: s.display_order
    }))
  })
  
  // åˆå¹¶æ¥å£æ–­å¥å’Œæœ¬åœ°æ–°æ’å…¥çš„æ–­å¥
  const allBreakingSentences = [...breakingSentences, ...localBreakingSentences]
  
  console.log('ğŸ” [getBreakingSentencesFromApi] æ’åºå‰', {
    breakingSentences: breakingSentences.map(s => ({
      sentence_id: s.sentence_id,
      content: s.content,
      display_order: s.display_order
    })),
    localBreakingSentences: localBreakingSentences.map(s => ({
      sentence_id: s.sentence_id,
      content: s.content,
      display_order: s.display_order
    })),
    allBreakingSentences: allBreakingSentences.map(s => ({
      sentence_id: s.sentence_id,
      content: s.content,
      display_order: s.display_order
    }))
  })
  
  const sortedBreakingSentences = allBreakingSentences.sort((a, b) => (a.display_order || 0) - (b.display_order || 0))
  
  console.log('ğŸ” [getBreakingSentencesFromApi] æ’åºå', {
    sortedBreakingSentences: sortedBreakingSentences.map(s => ({
      sentence_id: s.sentence_id,
      content: s.content,
      display_order: s.display_order
    }))
  })
  
  if (shouldLog) {
    console.log('âœ… [getBreakingSentencesFromApi] è¿”å›æ–­å¥åˆ—è¡¨', {
      originalSentenceId,
      count: sortedBreakingSentences.length,
      localCount: localBreakingSentences.length
    })
  }
  
  return sortedBreakingSentences
}

// è·å–æ‹†å¥å†…å®¹ï¼šå°†æ‰€æœ‰å­å¥å­æ‹¼æ¥èµ·æ¥ï¼ˆå“åº”å¼ï¼‰
const getCombinedSentenceContent = (sentence) => {
  // ä½¿ç”¨ computed æ¥ç¡®ä¿å“åº”å¼æ›´æ–°
  // ä½†ç”±äºè¿™æ˜¯åœ¨æ¨¡æ¿ä¸­è°ƒç”¨çš„å‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿å®ƒèƒ½å¤Ÿè¿½è¸ªåˆ° sentences.value çš„å˜åŒ–
  const children = sentences.value
    .filter((item) => item.parent_id === sentence.sentence_id)
    .sort((a, b) => (a.display_order || 0) - (b.display_order || 0))
  
  // å¦‚æœæœ‰å­å¥å­ï¼Œå°†æ‰€æœ‰å­å¥å­çš„å†…å®¹æ‹¼æ¥èµ·æ¥
  if (children.length > 0) {
    // è®¿é—®æ¯ä¸ªå­å¥å­çš„ contentï¼Œç¡®ä¿ Vue èƒ½å¤Ÿè¿½è¸ªåˆ°å˜åŒ–
    return children.map(sub => {
      // ç¡®ä¿è®¿é—® content å±æ€§ï¼Œè§¦å‘å“åº”å¼è¿½è¸ª
      const content = sub.content || ''
      return content
    }).join('')
  }
  
  // å¦‚æœæ²¡æœ‰å­å¥å­ï¼Œè¿”å›çˆ¶å¥å­çš„åŸå§‹å†…å®¹
  return sentence.content || ''
}

// ä»contentä¸­æå–çº¯æ–‡æœ¬ï¼Œç§»é™¤æ‰€æœ‰æ ‡ç­¾ï¼ˆåœé¡¿ã€é™éŸ³ã€å¤šéŸ³å­—ç­‰ï¼‰
const extractPlainText = (content, sentenceId = null) => {
  // åªæ‰“å°ç¬¬ä¸€å¥çš„æ—¥å¿—
  const isFirstSentence = sentenceId && rootSentences.value.length > 0 && rootSentences.value[0].sentence_id === sentenceId
  if (isFirstSentence) {
    console.log('extractPlainText [ç¬¬ä¸€å¥]', sentenceId, 'è¾“å…¥é•¿åº¦:', content?.length, 'å†…å®¹:', content)
  }
  if (!content || typeof content !== 'string') return ''
  // ç§»é™¤åœé¡¿æ ‡ç­¾: <pause:1.0> æˆ– <pause>
  let plainText = content.replace(/<pause(?::[\d.]+)?>/g, '')
  // ç§»é™¤é™éŸ³æ ‡ç­¾: <silence:1.0>
  plainText = plainText.replace(/<silence:[\d.]+>/g, '')
  // ç§»é™¤å¯èƒ½çš„å…¶ä»–HTMLæ ‡ç­¾ï¼ˆå¦‚æœæœ‰ï¼‰
  plainText = plainText.replace(/<[^>]+>/g, '')
  if (isFirstSentence) {
    console.log('extractPlainText [ç¬¬ä¸€å¥]', sentenceId, 'è¾“å‡ºé•¿åº¦:', plainText?.length, 'å†…å®¹:', plainText)
  }
  return plainText
}

// ä¸ºæ¯ä¸ªæ ¹å¥å­åˆ›å»ºå“åº”å¼çš„æ‹¼æ¥å†…å®¹è®¡ç®—å±æ€§
const sentenceCombinedContentMap = computed(() => {
  const map = {}
  rootSentences.value.forEach((sentence, index) => {
    const isFirstSentence = index === 0
    const children = sentences.value
      .filter((item) => item.parent_id === sentence.sentence_id)
      .sort((a, b) => (a.display_order || 0) - (b.display_order || 0))
    
    if (children.length > 0) {
      // æå–çº¯æ–‡æœ¬ï¼Œç§»é™¤æ‰€æœ‰æ ‡ç­¾
      const parts = children.map(sub => {
        if (isFirstSentence) {
          console.log('[ç¬¬ä¸€å¥] å­å¥å­å†…å®¹ before extract:', sub.sentence_id, 'é•¿åº¦:', sub.content?.length, 'å†…å®¹:', sub.content)
        }
        const plain = extractPlainText(sub.content || '', sentence.sentence_id)
        if (isFirstSentence) {
          console.log('[ç¬¬ä¸€å¥] å­å¥å­å†…å®¹ after extract:', sub.sentence_id, 'é•¿åº¦:', plain?.length, 'å†…å®¹:', plain)
        }
        return plain
      })
      map[sentence.sentence_id] = parts.join('')
      if (isFirstSentence) {
        console.log('[ç¬¬ä¸€å¥] åˆå¹¶åå†…å®¹:', sentence.sentence_id, 'é•¿åº¦:', map[sentence.sentence_id]?.length, 'å†…å®¹:', map[sentence.sentence_id])
      }
    } else {
      // æå–çº¯æ–‡æœ¬ï¼Œç§»é™¤æ‰€æœ‰æ ‡ç­¾
      if (isFirstSentence) {
        console.log('[ç¬¬ä¸€å¥] æ ¹å¥å­å†…å®¹ before extract:', sentence.sentence_id, 'é•¿åº¦:', sentence.content?.length, 'å†…å®¹:', sentence.content)
      }
      map[sentence.sentence_id] = extractPlainText(sentence.content || '', sentence.sentence_id)
      if (isFirstSentence) {
        console.log('[ç¬¬ä¸€å¥] æ ¹å¥å­å†…å®¹ after extract:', sentence.sentence_id, 'é•¿åº¦:', map[sentence.sentence_id]?.length, 'å†…å®¹:', map[sentence.sentence_id])
      }
    }
  })
  return map
})

// è·å–æ‹†å¥å†…å®¹ï¼ˆä½¿ç”¨è®¡ç®—å±æ€§ï¼‰
const getCombinedSentenceContentReactive = (sentence) => {
  // sentenceCombinedContentMap å·²ç»å¤„ç†è¿‡çº¯æ–‡æœ¬æå–ï¼Œç›´æ¥è¿”å›å³å¯
  const content = sentenceCombinedContentMap.value[sentence.sentence_id]
  if (content !== undefined) {
    return content
  }
  // å¦‚æœæ²¡æœ‰åœ¨ map ä¸­ï¼Œè¯´æ˜å¯èƒ½æ˜¯æ–°æ•°æ®ï¼Œéœ€è¦æå–çº¯æ–‡æœ¬
  return extractPlainText(sentence.content || '')
}

const ensurePolyphonicState = (sentenceId) => {
  if (!sentenceId) return null
  if (!polyphonicStateMap[sentenceId]) {
    polyphonicStateMap[sentenceId] = {
      selections: {},
      markers: []
    }
  }
  if (typeof polyphonicModeMap[sentenceId] === 'undefined') {
    polyphonicModeMap[sentenceId] = false
  }
  return polyphonicStateMap[sentenceId]
}

const getPolyphonicMarkers = (sub) => {
  if (!sub) return []
  return polyphonicStateMap[sub.sentence_id]?.markers || []
}

const isPolyphonicModeActive = (sub) => {
  if (!sub) return false
  return !!polyphonicModeMap[sub.sentence_id]
}

const buildPolyphonicMarkers = (sub) => {
  if (!sub) return []
  const content = sub.content || ''
  const sentenceId = sub.sentence_id
  const state = ensurePolyphonicState(sentenceId)
  if (!content) {
    state.markers = []
    return []
  }

  let results = []
  try {
    results = polyphonic(content, { type: 'array' })
  } catch (error) {
    console.warn('polyphonic parse failed:', error)
    state.markers = []
    return []
  }

  const markers = []
  for (let i = 0; i < content.length; i += 1) {
    const char = content[i]
    const optionsRaw = results[i] || []
    const normalizedOptions = (optionsRaw || [])
      .map((item) => (item || '').trim())
      .filter((item) => item && item !== char)
    const uniqueOptions = [...new Set(normalizedOptions)]
    if (uniqueOptions.length <= 1) continue

    const markerId = `${sentenceId}-${i}`
    const selected = state.selections?.[markerId] || null
    markers.push({
      id: markerId,
      sentenceId,
      offset: i,
      length: 1,
      char,
      options: uniqueOptions,
      selected
    })
  }

  state.markers = markers
  return markers
}

const refreshPolyphonicForSub = (sub) => {
  if (!sub) return
  ensurePolyphonicState(sub.sentence_id)
  buildPolyphonicMarkers(sub)
}

const isClearingText = ref(false)

const selectSubSentence = (sub) => {
  if (!sub) return
  editingSubSentenceId.value = sub.sentence_id
  editingForm.sentenceId = sub.sentence_id
  editingForm.content = sub.content
  editingForm.voice = sub.voice || 'default'
  editingForm.volume = clampVolume(sub.volume)
  editingForm.speed = clampSpeed(sub.speed)
  editingForm.pitch = sub.pitch || 50
  refreshPolyphonicForSub(sub)
}

const setEditorRef = (id, instance) => {
  if (instance) {
    editorRefs[id] = instance
  } else {
    delete editorRefs[id]
  }
}

const handleEditorSelectionChange = (sub, payload = {}) => {
  pauseEligibilityMap[sub.sentence_id] = !!payload?.hasTextBefore
  selectionStateMap[sub.sentence_id] = {
    ...payload,
    sentenceId: sub.sentence_id
  }
}

const handleEditorContentChange = (sub) => {
  if (!sub) return
  refreshPolyphonicForSub(sub)
}

const handleEditorFocus = (sub) => {
  if (!sub) return
  if (editingSubSentenceId.value !== sub.sentence_id) {
    selectSubSentence(sub)
  }
}

const currentSelectionContext = computed(() => {
  if (!editingSubSentenceId.value) return null
  return selectionStateMap[editingSubSentenceId.value] || null
})

const localSpeedDialog = reactive({
  visible: false,
  sentenceId: '',
  docFrom: 0,
  docTo: 0,
  rangeLength: 0,
  value: 0
})

const handleRequestLocalSpeed = (context = {}) => {
  if (!editingSubSentenceId.value) return
  const range = context.selectionRange
  if (!range || range.length <= 0) return
  localSpeedDialog.visible = true
  localSpeedDialog.sentenceId = editingSubSentenceId.value
  localSpeedDialog.docFrom = range.docFrom
  localSpeedDialog.docTo = range.docTo
  localSpeedDialog.rangeLength = range.length
  localSpeedDialog.value = clampSpeed(editingForm.speed)
}

const handleCancelLocalSpeed = () => {
  localSpeedDialog.visible = false
  localSpeedDialog.sentenceId = ''
  localSpeedDialog.docFrom = 0
  localSpeedDialog.docTo = 0
  localSpeedDialog.rangeLength = 0
}

const handleConfirmLocalSpeed = () => {
  if (!localSpeedDialog.visible || !localSpeedDialog.sentenceId) {
    return
  }
  const editor = editorRefs[localSpeedDialog.sentenceId]
  if (editor?.applyLocalSpeedRange) {
    editor.applyLocalSpeedRange(
      localSpeedDialog.docFrom,
      localSpeedDialog.docTo,
      localSpeedDialog.value
    )
  }
  handleCancelLocalSpeed()
}

const handleSpeedSegmentsChange = ({ sub, segments }) => {
  if (!sub) return
  sub.speedSegments = Array.isArray(segments) ? [...segments] : []
}

const handleClearText = async (rootSentence) => {
  if (!rootSentence) return
  isClearingText.value = true

  // å…ˆæ¸…ç©ºåŸå§‹æ‹†å¥å†…å®¹ï¼Œé˜²æ­¢åç»­åŒæ­¥åˆæŠŠæ—§æ–‡æœ¬å†™å›
  rootSentence.content = ''
  const children = sentences.value
    .filter((item) => item.parent_id === rootSentence.sentence_id)
    .sort((a, b) => (a.display_order || 0) - (b.display_order || 0))

  const [keeper, ...toDelete] = children

  // åˆ é™¤å¤šä½™çš„å­å¥å­
  for (const child of toDelete) {
    try {
        await deleteSentenceApi(child.sentence_id)
    } catch (error) {
      console.error('åˆ é™¤å­å¥å­å¤±è´¥:', error)
    }
    const index = sentences.value.findIndex(
      (item) => item.sentence_id === child.sentence_id
    )
    if (index !== -1) {
      sentences.value.splice(index, 1)
    }
  }

  let target = keeper

  if (target) {
    target.content = ''
    target.speedSegments = []
    editingForm.content = ''
    refreshPolyphonicForSub(target)
  } else {
    // æ²¡æœ‰å­å¥å­æ—¶åˆ›å»ºä¸€ä¸ªæ–°çš„ç©ºè¾“å…¥æ¡†
    const newSentence = insertSentenceAfterLocal(rootSentence.sentence_id, {
      content: '',
      parent_id: rootSentence.sentence_id
    })
    if (newSentence && newSentence.sentence_id) {
      ensurePolyphonicState(newSentence.sentence_id)
      newSentence.speedSegments = []
      target = newSentence
    }
  }

  if (target) {
    editingForm.content = ''
    editingSubSentenceId.value = target.sentence_id
  }
  isClearingText.value = false
  if (target) {
    selectSubSentence(target)
  }
}
watch(
  () => editingSubSentenceId.value,
  () => {
    if (isClearingText.value) return
    const sub = currentSubSentence.value
    if (sub) {
      editingForm.sentenceId = sub.sentence_id
      editingForm.content = sub.content
      editingForm.voice = sub.voice || 'default'
      editingForm.volume = clampVolume(sub.volume)
      editingForm.speed = clampSpeed(sub.speed)
      editingForm.pitch = sub.pitch || 50
    }
  }
)

watch(
  () => currentSubSentence.value && currentSubSentence.value.content,
  (val) => {
    if (isClearingText.value) return
    if (typeof val === 'string') {
      editingForm.content = val
    }
  }
)

watch(
  () => [
    editingForm.voice,
    editingForm.volume,
    editingForm.speed,
    editingForm.pitch
  ],
  () => {
    const sub = currentSubSentence.value
    if (sub) {
      sub.voice = editingForm.voice
      sub.volume = clampVolume(editingForm.volume)
      sub.speed = clampSpeed(editingForm.speed)
      sub.pitch = editingForm.pitch
    }
  }
)

watch(
  () => editingForm.volume,
  (val) => {
    const clamped = clampVolume(val)
    if (clamped !== val) {
      editingForm.volume = clamped
    }
  }
)

watch(
  () => editingForm.speed,
  (val) => {
    const clamped = clampSpeed(val)
    if (clamped !== val) {
      editingForm.speed = clamped
    }
  }
)

// ä»å…¨å±€æ³¨å…¥è·å–éŸ³è‰²åˆ—è¡¨
const globalVoiceList = inject('globalVoiceList', ref([]))

// æ ¹æ®éŸ³è‰²ç±»å‹åˆ†ç»„
const voiceCategories = computed(() => {
  const categories = new Set()
  globalVoiceList.value.forEach(voice => {
    if (voice.voiceType) {
      categories.add(voice.voiceType)
    }
  })
  // å¦‚æœæ²¡æœ‰éŸ³è‰²æ•°æ®ï¼Œè¿”å›é»˜è®¤åˆ†ç±»
  if (categories.size === 0) {
    return [
      { label: 'æ–°é—»', value: 'news' },
      { label: 'å°è¯´', value: 'novel' }
    ]
  }
  // å°†ç±»å‹è½¬æ¢ä¸ºåˆ†ç±»æ ¼å¼
  const categoryMap = {
    'news': { label: 'æ–°é—»', value: 'news' },
    'novel': { label: 'å°è¯´', value: 'novel' },
    'children': { label: 'å„¿ç«¥', value: 'children' },
    'image': { label: 'å½¢è±¡', value: 'image' }
  }
  return Array.from(categories).map(type => {
    return categoryMap[type] || { label: type, value: type }
  })
})

const activeVoiceCategory = ref('news')

// å°† API è¿”å›çš„éŸ³è‰²æ•°æ®è½¬æ¢ä¸º voiceOptions æ ¼å¼
const voiceOptions = computed(() => {
  if (!globalVoiceList.value || globalVoiceList.value.length === 0) {
    // å¦‚æœæ²¡æœ‰éŸ³è‰²æ•°æ®ï¼Œè¿”å›é»˜è®¤å€¼
    return [
      { label: 'å”ç‘¶', value: 'default', desc: 'çœŸå®3.0', tag: 'æ–°é—»', avatar: 'å”' },
      { label: 'æœå­', value: 'female1', desc: 'äº²å­3.0VC', tag: 'å„¿ç«¥', avatar: 'æœ' },
      { label: 'æ¨ç¬™', value: 'male1', desc: 'å½¢è±¡3.0', tag: 'å½¢è±¡', avatar: 'æ¨' }
    ]
  }
  
  // æŒ‰ sortOrder æ’åº
  const sortedVoices = [...globalVoiceList.value].sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0))
  
  return sortedVoices.map(voice => {
    // è·å–éŸ³è‰²åç§°çš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä½œä¸ºå¤´åƒ
    const avatar = voice.voiceName ? voice.voiceName.charAt(0) : 'éŸ³'
    
    // æ ¹æ® voiceType ç¡®å®šæ ‡ç­¾
    const tagMap = {
      'news': 'æ–°é—»',
      'novel': 'å°è¯´',
      'children': 'å„¿ç«¥',
      'image': 'å½¢è±¡'
    }
    const tag = tagMap[voice.voiceType] || voice.voiceType || 'é»˜è®¤'
    
    // ç”Ÿæˆæè¿°ï¼ˆå¯ä»¥æ ¹æ®å®é™…éœ€æ±‚è°ƒæ•´ï¼‰
    const desc = voice.isRecommended ? 'æ¨è' : 'æ ‡å‡†'
    
    return {
      label: voice.voiceName,
      value: voice.voiceId,
      desc: desc,
      tag: tag,
      avatar: avatar,
      voiceType: voice.voiceType,
      avatar_url: voice.avatar_url || '' // api2.md: ä½¿ç”¨ avatar_url
    }
  })
})

const customOptions = [
  {
    label: 'éŸ³é‡',
    icon: 'Headset',
    controlKey: 'volume',
    min: 0,
    max: 100,
    step: 1
  },
  {
    label: 'è¯­é€Ÿ',
    icon: 'MagicStick',
    controlKey: 'speed',
    min: -10,
    max: 10,
    step: 1
  },
  { label: 'æ–­å¥æ ‡å‡†', icon: 'Tickets', actionKey: 'split-standard' },
  { label: 'åœé¡¿', icon: 'Timer', actionKey: 'pause' },
  { label: 'å¤šéŸ³å­—', icon: 'ChatLineSquare', actionKey: 'polyphonic' },
  { label: 'æ’å…¥é™éŸ³', icon: 'Bell', actionKey: 'silence' },
  { label: 'é˜…è¯»è§„èŒƒ', icon: 'CollectionTag', actionKey: 'reading-rules' }
]

// æ»šåŠ¨å¤„ç†å‡½æ•°
const handleScroll = async (event) => {
  const target = event.target
  if (!target) return
  
  // è®¡ç®—æ˜¯å¦æ»šåŠ¨åˆ°åº•éƒ¨ï¼ˆè·ç¦»åº•éƒ¨100pxæ—¶è§¦å‘ï¼‰
  const scrollTop = target.scrollTop
  const scrollHeight = target.scrollHeight
  const clientHeight = target.clientHeight
  
  // è·ç¦»åº•éƒ¨100pxæ—¶åŠ è½½æ›´å¤š
  if (scrollHeight - scrollTop - clientHeight < 100) {
    if (hasMore.value && !loadingMore.value && !loading.value) {
      const listData = await loadMoreSentences()
      if (listData) {
        // åˆå¹¶æ–°çš„åŸå§‹æ•°æ®
        if (originalSentenceListData.value && listData.data) {
          originalSentenceListData.value.data.list = [
            ...(originalSentenceListData.value.data.list || []),
            ...(listData.data.list || [])
          ]
        } else if (listData.data) {
          originalSentenceListData.value = listData
        }
        
        // åˆå§‹åŒ–æ–°åŠ è½½çš„æ‹†å¥çš„åˆæˆçŠ¶æ€
        if (listData.data && listData.data.list) {
          initializeOriginalSentenceStatus(listData)
        }
      }
    }
  }
}

// æ£€æŸ¥ä»»åŠ¡åˆæˆçŠ¶æ€
const checkTaskSynthesisStatus = async () => {
  if (!taskId.value) return
  
  try {
    const taskDetail = await getTaskDetail(parseInt(taskId.value))
    
    // å“åº”æ‹¦æˆªå™¨è¿”å›çš„æ˜¯ res.dataï¼Œæ‰€ä»¥ taskDetail å°±æ˜¯ data å¯¹è±¡
    // å¦‚æœ taskDetail æœ‰ data å±æ€§ï¼Œè¯´æ˜æ˜¯åµŒå¥—ç»“æ„ï¼Œå¦åˆ™ taskDetail æœ¬èº«å°±æ˜¯ data
    const data = taskDetail.data !== undefined ? taskDetail.data : taskDetail
    const status = data?.status
    const mergeId = data?.mergeId
    
    // æ›´æ–°ä»»åŠ¡çŠ¶æ€ï¼ˆç¡®ä¿æ˜¯æ•°å­—ç±»å‹ï¼‰
    taskStatus.value = status !== undefined ? Number(status) : null
    taskMergeId.value = mergeId
    
    // status: 0-æ‹†å¥å®Œæˆï¼Œ1-è¯­éŸ³åˆæˆä¸­ï¼Œ2-è¯­éŸ³åˆæˆæˆåŠŸï¼Œ3-è¯­éŸ³åˆæˆå¤±è´¥ï¼Œ4-è¯­éŸ³åˆå¹¶ä¸­ï¼Œ5-è¯­éŸ³åˆå¹¶æˆåŠŸï¼Œ6-è¯­éŸ³åˆå¹¶å¤±è´¥
    if (status === 1) {
      // å¦‚æœçŠ¶æ€æ˜¯"è¯­éŸ³åˆæˆä¸­"ï¼ˆstatus === 1ï¼‰ï¼Œå¯åŠ¨è½®è¯¢
      ElMessage.info('æ£€æµ‹åˆ°ä»»åŠ¡æ­£åœ¨åˆæˆä¸­ï¼Œå°†æ˜¾ç¤ºåˆæˆè¿›åº¦ã€‚')
      taskSynthesisProgress.value.visible = true
      taskSynthesisProgress.value.status = 'processing'
      taskSynthesisProgress.value.statusText = 'åˆæˆä¸­'
      startPollingTaskSynthesis()
    } else if (status === 4) {
      // status = 4ï¼ˆè¯­éŸ³åˆå¹¶ä¸­ï¼‰ï¼Œç›´æ¥è·³è½¬åˆ°éŸ³é¢‘åˆæˆé¡µé¢ï¼Œå¹¶ä¼ é€’ mergeId å‚æ•°
      if (mergeId) {
        router.push({
          name: 'MergeAudioProgress',
          query: {
            taskId: taskId.value,
            mergeId: mergeId
          }
        })
      } else {
        router.push({
          name: 'MergeAudioProgress',
          query: {
            taskId: taskId.value
          }
        })
      }
    } else if (status === 5) {
      // status = 5ï¼ˆè¯­éŸ³åˆå¹¶æˆåŠŸï¼‰ï¼Œå¼¹å‡ºæç¤ºæ¡†
      try {
        await ElMessageBox.confirm(
          'å½“å‰ä»»åŠ¡å·²å®Œæˆï¼Œæ˜¯å¦æŸ¥çœ‹éŸ³é¢‘åˆå¹¶ç»“æœï¼Ÿ',
          'æç¤º',
          {
            confirmButtonText: 'æŸ¥çœ‹åˆæˆéŸ³é¢‘',
            cancelButtonText: 'å–æ¶ˆ',
            type: 'success',
            distinguishCancelAndClose: true
          }
        )
        
        // ç”¨æˆ·ç‚¹å‡»äº†"æŸ¥çœ‹åˆæˆéŸ³é¢‘"
        if (mergeId) {
          router.push({
            name: 'MergeAudioProgress',
            query: {
              taskId: taskId.value,
              mergeId: mergeId
            }
          })
        } else {
          router.push({
            name: 'MergeAudioProgress',
            query: {
              taskId: taskId.value
            }
          })
        }
      } catch (error) {
        // ç”¨æˆ·ç‚¹å‡»äº†"å–æ¶ˆ"ï¼Œåœç•™åœ¨å½“å‰ç²¾ä¿®é¡µé¢
        if (error === 'cancel') {
          // ä»€ä¹ˆéƒ½ä¸åšï¼Œåœç•™åœ¨å½“å‰é¡µé¢
        }
      }
    }
  } catch (error) {
    console.error('è·å–ä»»åŠ¡è¯¦æƒ…å¤±è´¥:', error)
  }
}

// è·å– taskId çš„è¾…åŠ©å‡½æ•°ï¼ŒåŒæ—¶æ”¯æŒ taskId å’Œ task_id ä¸¤ç§å‚æ•°åï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼‰
const getTaskIdFromRoute = () => {
  return route.query.taskId || route.query.task_id
}

onMounted(() => {
  taskId.value = getTaskIdFromRoute()
  if (taskId.value) {
    refreshSentences()
  } else {
    ElMessage.error('ç¼ºå°‘ä»»åŠ¡IDå‚æ•°')
  }
})

// ç›‘å¬è·¯ç”±å˜åŒ–ï¼Œå½“ä»å…¶ä»–é¡µé¢è¿”å›æ—¶é‡æ–°åŠ è½½æ•°æ®
watch(
  () => route.query.taskId || route.query.task_id,
  (newTaskId) => {
    if (newTaskId && newTaskId !== taskId.value) {
      taskId.value = newTaskId
      refreshSentences()
    }
  },
  { immediate: false }
)

// ç»„ä»¶å¸è½½æ—¶æ¸…ç†å®šæ—¶å™¨å’Œåœæ­¢éŸ³é¢‘
onBeforeUnmount(() => {
  // æ¸…é™¤æ‰€æœ‰æ‹†å¥è½®è¯¢å®šæ—¶å™¨
  Object.values(originalSentenceStatus.value).forEach(statusInfo => {
    if (statusInfo.timer) {
      clearInterval(statusInfo.timer)
    }
  })
  originalSentenceStatus.value = {}
  
  // æ¸…é™¤æ‰€æœ‰æ–­å¥è½®è¯¢å®šæ—¶å™¨
  Object.values(breakingSentenceStatus.value).forEach(statusInfo => {
    if (statusInfo.timer) {
      clearInterval(statusInfo.timer)
    }
  })
  breakingSentenceStatus.value = {}
  
  // åœæ­¢æ‰€æœ‰éŸ³é¢‘æ’­æ”¾
  stopAllPlayingAudio()
})

// æ ¹æ®åˆ—è¡¨æ•°æ®åˆå§‹åŒ–æ‹†å¥åˆæˆçŠ¶æ€
const initializeOriginalSentenceStatus = (listData) => {
  if (!listData || !Array.isArray(listData.list)) return
  
  listData.list.forEach((originalSentence) => {
    const originalSentenceId = originalSentence.originalSentenceId
    if (!originalSentenceId) return
    
    // æ˜ å°„ synthesisStatus: 0-æœªåˆæˆï¼Œ1-åˆæˆä¸­ï¼Œ2-å·²åˆæˆï¼Œ3-åˆæˆå¤±è´¥
    const statusMap = {
      0: 'pending',
      1: 'processing',
      2: 'completed',
      3: 'failed'
    }
    const status = statusMap[originalSentence.synthesisStatus] || 'pending'
    
    // åˆå§‹åŒ–çŠ¶æ€ï¼Œå¦‚æœå·²å­˜åœ¨ä¸”æ­£åœ¨è½®è¯¢ä¸­ï¼Œåˆ™ä¿ç•™å®šæ—¶å™¨ï¼Œåªæ›´æ–°çŠ¶æ€ï¼ˆå¦‚æœåˆ—è¡¨çŠ¶æ€æ›´å‡†ç¡®ï¼‰
    const existingStatus = originalSentenceStatus.value[originalSentenceId]
    
    if (!existingStatus) {
      // æ–°å»ºçŠ¶æ€
      originalSentenceStatus.value[originalSentenceId] = {
        status,
        audioUrlList: [],
        timer: null
      }
    } else {
      // å¦‚æœå·²æœ‰çŠ¶æ€
      // å¦‚æœæ­£åœ¨è½®è¯¢ä¸­ï¼ˆæœ‰å®šæ—¶å™¨ï¼‰ï¼Œä¸”åˆ—è¡¨çŠ¶æ€æ˜¯"å·²åˆæˆ"æˆ–"å¤±è´¥"ï¼Œè¯´æ˜è½®è¯¢å¯èƒ½å·²ç»å®Œæˆï¼Œæ›´æ–°çŠ¶æ€
      if (existingStatus.timer) {
        // å¦‚æœåˆ—è¡¨æ˜¾ç¤ºå·²å®Œæˆæˆ–å¤±è´¥ï¼Œä½†è½®è¯¢è¿˜åœ¨è¿›è¡Œï¼Œå¯èƒ½æ˜¯æ•°æ®ä¸åŒæ­¥ï¼Œä»¥åˆ—è¡¨ä¸ºå‡†
        if (status === 'completed' || status === 'failed') {
          existingStatus.status = status
          // å¦‚æœå·²å®Œæˆï¼Œæ¸…é™¤å®šæ—¶å™¨ï¼ˆå¯èƒ½åˆ—è¡¨æ•°æ®å·²æ›´æ–°ï¼‰
          if (status === 'completed' || status === 'failed') {
            clearInterval(existingStatus.timer)
            existingStatus.timer = null
          }
        }
      } else {
        // æ²¡æœ‰å®šæ—¶å™¨ï¼Œç›´æ¥æ›´æ–°çŠ¶æ€
        existingStatus.status = status
      }
    }
    
    // å¦‚æœå·²åˆæˆï¼Œå°è¯•ä»æ–­å¥åˆ—è¡¨ä¸­æ„å»º audioUrlList
    if (status === 'completed' && Array.isArray(originalSentence.breakingSentenceList)) {
      const audioUrlList = originalSentence.breakingSentenceList
        .filter(bs => bs.audioUrl) // åªåŒ…å«æœ‰éŸ³é¢‘çš„æ–­å¥
        .map(bs => ({
          sequence: bs.sequence || 0,
          audioUrl: bs.audioUrl
        }))
        .sort((a, b) => a.sequence - b.sequence)
      
      if (audioUrlList.length > 0) {
        originalSentenceStatus.value[originalSentenceId].audioUrlList = audioUrlList
      }
    }
  })
}

// æ ¹æ®åˆ—è¡¨æ•°æ®åˆå§‹åŒ–æ–­å¥åˆæˆçŠ¶æ€
const initializeBreakingSentenceStatus = (listData) => {
  console.log('ğŸ”µ [initializeBreakingSentenceStatus] å¼€å§‹åˆå§‹åŒ–æ–­å¥çŠ¶æ€', {
    hasListData: !!listData,
    isArray: Array.isArray(listData?.list),
    listLength: listData?.list?.length || 0
  })
  
  if (!listData || !Array.isArray(listData.list)) {
    console.warn('âš ï¸ [initializeBreakingSentenceStatus] æ•°æ®æ— æ•ˆï¼Œè·³è¿‡åˆå§‹åŒ–')
    return
  }
  
  let totalBreakingSentences = 0
  let initializedCount = 0
  
  listData.list.forEach((originalSentence, origIndex) => {
    if (!Array.isArray(originalSentence.breakingSentenceList)) return
    
    originalSentence.breakingSentenceList.forEach((breakingSentence, breakIndex) => {
      totalBreakingSentences++
      const breakingSentenceId = breakingSentence.breakingSentenceId
      if (!breakingSentenceId) {
        console.warn(`âš ï¸ [initializeBreakingSentenceStatus] æ–­å¥ ${breakIndex} ç¼ºå°‘ breakingSentenceId`)
        return
      }
      
      // ç»Ÿä¸€ä½¿ç”¨å­—ç¬¦ä¸² ID ä½œä¸ºé”®ï¼Œé¿å…ç±»å‹ä¸åŒ¹é…é—®é¢˜
      const id = String(breakingSentenceId)
      
      // æ˜ å°„ synthesisStatus: 0-æœªåˆæˆï¼Œ1-åˆæˆä¸­ï¼Œ2-å·²åˆæˆï¼Œ3-åˆæˆå¤±è´¥
      const statusMap = {
        0: 'pending',
        1: 'processing',
        2: 'completed',
        3: 'failed'
      }
      const status = statusMap[breakingSentence.synthesisStatus] || 'pending'
      const audioUrl = breakingSentence.audioUrl || ''
      
      // console.log(`ğŸ“ [initializeBreakingSentenceStatus] å¤„ç†æ–­å¥`, {
      //   originalSentenceIndex: origIndex,
      //   breakingSentenceIndex: breakIndex,
      //   breakingSentenceId: breakingSentenceId,
      //   idType: typeof breakingSentenceId,
      //   idString: id,
      //   synthesisStatus: breakingSentence.synthesisStatus,
      //   mappedStatus: status,
      //   audioUrl: audioUrl,
      //   hasAudioUrl: !!audioUrl
      // })
      
      // åˆå§‹åŒ–çŠ¶æ€ï¼Œå¦‚æœå·²å­˜åœ¨ä¸”æ­£åœ¨è½®è¯¢ä¸­ï¼Œåˆ™ä¿ç•™å®šæ—¶å™¨ï¼Œåªæ›´æ–°çŠ¶æ€ï¼ˆå¦‚æœåˆ—è¡¨çŠ¶æ€æ›´å‡†ç¡®ï¼‰
      const existingStatus = breakingSentenceStatus.value[id] || breakingSentenceStatus.value[breakingSentenceId]
      
      if (!existingStatus) {
        // æ–°å»ºçŠ¶æ€ï¼Œç»Ÿä¸€ä½¿ç”¨å­—ç¬¦ä¸² ID ä½œä¸ºé”®
        breakingSentenceStatus.value[id] = {
          status,
          audioUrl,
          timer: null
        }
        initializedCount++
        // console.log(`âœ… [initializeBreakingSentenceStatus] æ–°å»ºçŠ¶æ€`, {
        //   id,
        //   status,
        //   audioUrl,
        //   storedKeys: Object.keys(breakingSentenceStatus.value)
        // })
        
        // å¦‚æœåŸ ID æ˜¯æ•°å­—ï¼Œä¹Ÿå­˜å‚¨ä¸€ä»½æ•°å­—ç‰ˆæœ¬ï¼Œç¡®ä¿å…¼å®¹æ€§
        if (!isNaN(breakingSentenceId) && String(breakingSentenceId) !== id) {
          breakingSentenceStatus.value[breakingSentenceId] = breakingSentenceStatus.value[id]
          console.log(`ğŸ“Œ [initializeBreakingSentenceStatus] åŒæ—¶å­˜å‚¨æ•°å­—ç‰ˆæœ¬`, {
            numericId: breakingSentenceId,
            stringId: id
          })
        }
      } else {
        // å¦‚æœå·²æœ‰çŠ¶æ€ï¼Œæ›´æ–°åˆ°å­—ç¬¦ä¸² ID é”®
        const statusObj = breakingSentenceStatus.value[id] || existingStatus
        
        // console.log(`ğŸ”„ [initializeBreakingSentenceStatus] æ›´æ–°å·²æœ‰çŠ¶æ€`, {
        //   id,
        //   oldStatus: statusObj.status,
        //   newStatus: status,
        //   oldAudioUrl: statusObj.audioUrl,
        //   newAudioUrl: audioUrl,
        //   hasTimer: !!statusObj.timer
        // })
        
        // å¦‚æœæ­£åœ¨è½®è¯¢ä¸­ï¼ˆæœ‰å®šæ—¶å™¨ï¼‰ï¼Œä¸”åˆ—è¡¨çŠ¶æ€æ˜¯"å·²åˆæˆ"æˆ–"å¤±è´¥"ï¼Œè¯´æ˜è½®è¯¢å¯èƒ½å·²ç»å®Œæˆï¼Œæ›´æ–°çŠ¶æ€
        if (statusObj.timer) {
          // å¦‚æœåˆ—è¡¨æ˜¾ç¤ºå·²å®Œæˆæˆ–å¤±è´¥ï¼Œä½†è½®è¯¢è¿˜åœ¨è¿›è¡Œï¼Œå¯èƒ½æ˜¯æ•°æ®ä¸åŒæ­¥ï¼Œä»¥åˆ—è¡¨ä¸ºå‡†
          if (status === 'completed' || status === 'failed') {
            statusObj.status = status
            statusObj.audioUrl = audioUrl
            // å¦‚æœå·²å®Œæˆï¼Œæ¸…é™¤å®šæ—¶å™¨ï¼ˆå¯èƒ½åˆ—è¡¨æ•°æ®å·²æ›´æ–°ï¼‰
            if (status === 'completed' || status === 'failed') {
              clearInterval(statusObj.timer)
              statusObj.timer = null
            }
          }
        } else {
          // æ²¡æœ‰å®šæ—¶å™¨ï¼Œç›´æ¥æ›´æ–°çŠ¶æ€
          statusObj.status = status
          statusObj.audioUrl = audioUrl
        }
        
        // ç¡®ä¿å­—ç¬¦ä¸² ID é”®å­˜åœ¨
        breakingSentenceStatus.value[id] = statusObj
        // å¦‚æœåŸ ID æ˜¯æ•°å­—ï¼Œä¹Ÿæ›´æ–°æ•°å­—ç‰ˆæœ¬
        if (!isNaN(breakingSentenceId) && String(breakingSentenceId) !== id) {
          breakingSentenceStatus.value[breakingSentenceId] = statusObj
        }
      }
    })
  })
  
  console.log('ğŸ”µ [initializeBreakingSentenceStatus] åˆå§‹åŒ–å®Œæˆ', {
    totalBreakingSentences,
    initializedCount,
    totalStatusKeys: Object.keys(breakingSentenceStatus.value).length,
    allStatusKeys: Object.keys(breakingSentenceStatus.value)
  })
}

const refreshSentences = async (preserveEditingState = false) => {
  try {
    // å¦‚æœè¦æ±‚ä¿æŒç¼–è¾‘çŠ¶æ€ï¼Œå…ˆä¿å­˜å½“å‰çŠ¶æ€
    let savedEditingSentenceId = null
    let savedEditingSubSentenceId = null
    if (preserveEditingState) {
      savedEditingSentenceId = editingSentenceId.value
      savedEditingSubSentenceId = editingSubSentenceId.value
      // ä¸´æ—¶æ¸…ç©ºç¼–è¾‘çŠ¶æ€ï¼Œé¿å…åˆ·æ–°æ—¶çš„è‡ªåŠ¨æ¢å¤é€»è¾‘
      editingSentenceId.value = null
      editingSubSentenceId.value = null
    }
    
    // åˆ·æ–°æ—¶é‡ç½®åˆ†é¡µï¼ŒåŠ è½½ç¬¬ä¸€é¡µï¼Œæ¯é¡µ10æ¡ï¼ˆapi2.md: page ä» 0 å¼€å§‹ï¼‰
    const listData = await loadSentences(taskId.value, 0, 10, false)
    
    // ä¿å­˜åŸå§‹æ•°æ®
    originalSentenceListData.value = listData
    
    // åˆ›å»º/æ›´æ–°æ•°æ®å¤‡ä»½ï¼ˆæ¯æ¬¡åˆ·æ–°éƒ½æ›´æ–°ï¼Œç¡®ä¿å¤‡ä»½æ˜¯æœ€æ–°çš„åŸå§‹æ•°æ®ï¼‰
    createBackup()
    
    // æ ¹æ®åˆ—è¡¨æ•°æ®åˆå§‹åŒ–æ‹†å¥åˆæˆçŠ¶æ€
    initializeOriginalSentenceStatus(listData)
    // æ ¹æ®åˆ—è¡¨æ•°æ®åˆå§‹åŒ–æ–­å¥åˆæˆçŠ¶æ€
    initializeBreakingSentenceStatus(listData)
    
    sentences.value.forEach((item) => ensurePolyphonicState(item.sentence_id))
    
    // æ£€æŸ¥ä»»åŠ¡çŠ¶æ€ï¼ˆåœ¨åˆ·æ–°æ•°æ®åï¼‰
    await checkTaskSynthesisStatus()
    
    // å¦‚æœè¦æ±‚ä¿æŒç¼–è¾‘çŠ¶æ€ï¼Œæ¢å¤ä¹‹å‰çš„çŠ¶æ€ï¼ˆä½†ä¸è‡ªåŠ¨åŠ è½½è¯¦æƒ…ï¼Œç”±è°ƒç”¨æ–¹å¤„ç†ï¼‰
    if (preserveEditingState && savedEditingSentenceId) {
      // savedEditingSentenceId æ¥è‡ª toggleEditï¼Œä¸€å®šæ˜¯æ‹†å¥ï¼Œç›´æ¥ä½¿ç”¨
      editingSentenceId.value = savedEditingSentenceId
      editingSubSentenceId.value = savedEditingSubSentenceId
      return // æå‰è¿”å›ï¼Œè®©è°ƒç”¨æ–¹å¤„ç†ç¼–è¾‘çŠ¶æ€çš„æ¢å¤
    }
    
    // é»˜è®¤è¡Œä¸ºï¼šå°è¯•æ¢å¤ç¼–è¾‘çŠ¶æ€
    if (editingSentenceId.value) {
      const current = sentences.value.find(
        (item) => item.sentence_id === editingSentenceId.value
      )
      if (current) {
        // éªŒè¯ current æ˜¯å¦æ˜¯æ‹†å¥ï¼ˆparent_id ä¸º 0 æˆ– nullï¼‰
        if (current.parent_id && current.parent_id !== 0) {
          // å¦‚æœ current æ˜¯æ–­å¥ï¼Œæ‰¾åˆ°å®ƒçš„çˆ¶æ‹†å¥
          console.warn('âš ï¸ [refreshSentences] editingSentenceId æ˜¯æ–­å¥ï¼ŒæŸ¥æ‰¾çˆ¶æ‹†å¥', {
            editingSentenceId: editingSentenceId.value,
            currentParentId: current.parent_id
          })
          const rootSentence = findSentenceById(current.parent_id)
          if (rootSentence) {
            editingSentenceId.value = rootSentence.sentence_id
            await loadSentenceDetail(rootSentence.sentence_id, rootSentence.content)
            const sub =
              findSentenceById(pendingSelectSubSentenceId.value) ||
              findSentenceById(editingSubSentenceId.value) ||
              current
            selectSubSentence(sub)
          } else {
            closeEditing()
          }
        } else {
          // current æ˜¯æ‹†å¥ï¼Œæ­£å¸¸å¤„ç†
          await loadSentenceDetail(current.sentence_id, current.content)
          const sub =
            findSentenceById(pendingSelectSubSentenceId.value) ||
            findSentenceById(editingSubSentenceId.value) ||
            current
          selectSubSentence(sub)
        }
        pendingSelectSubSentenceId.value = null
      } else {
        closeEditing()
      }
    } else if (pendingSelectSubSentenceId.value) {
      const sub = findSentenceById(pendingSelectSubSentenceId.value)
      if (sub) {
        // å¦‚æœ sub æ˜¯æ–­å¥ï¼Œç¡®ä¿ editingSentenceId æ˜¯å®ƒçš„çˆ¶æ‹†å¥
        if (sub.parent_id && sub.parent_id !== 0) {
          const rootSentence = findSentenceById(sub.parent_id)
          if (rootSentence) {
            editingSentenceId.value = rootSentence.sentence_id
          }
        }
        selectSubSentence(sub)
      }
      pendingSelectSubSentenceId.value = null
    }
  } catch (error) {
    console.error('åŠ è½½å¥å­åˆ—è¡¨å¤±è´¥:', error)
  }
}

// åˆ›å»ºæ•°æ®å¤‡ä»½
const createBackup = () => {
  // æ·±æ‹·è´ sentences
  backupSentences.value = JSON.parse(JSON.stringify(sentences.value))
  // æ·±æ‹·è´ originalSentenceListData
  if (originalSentenceListData.value) {
    backupOriginalSentenceListData.value = JSON.parse(JSON.stringify(originalSentenceListData.value))
  }
}

// ä»å¤‡ä»½æ¢å¤æ•°æ®
const restoreFromBackup = () => {
  if (!backupSentences.value) {
    console.warn('æ²¡æœ‰å¤‡ä»½æ•°æ®å¯æ¢å¤')
    return
  }
  
  // æ¢å¤ sentences
  sentences.value = JSON.parse(JSON.stringify(backupSentences.value))
  
  // æ¢å¤ originalSentenceListData
  if (backupOriginalSentenceListData.value) {
    originalSentenceListData.value = JSON.parse(JSON.stringify(backupOriginalSentenceListData.value))
  }
  
  // é‡æ–°åˆå§‹åŒ–åˆæˆçŠ¶æ€
  if (originalSentenceListData.value) {
    initializeOriginalSentenceStatus(originalSentenceListData.value)
  }
  
  // æ¸…ç†ç¼–è¾‘çŠ¶æ€ç›¸å…³çš„æ•°æ®
  Object.keys(polyphonicStateMap).forEach(key => {
    if (!sentences.value.find(s => s.sentence_id === key)) {
      delete polyphonicStateMap[key]
      delete polyphonicModeMap[key]
      delete pauseEligibilityMap[key]
      delete selectionStateMap[key]
      delete editorRefs[key]
    }
  })
  
  ElMessage.success('å·²æ¢å¤åˆ°åŸå§‹çŠ¶æ€')
}

const toggleEdit = async (sentence) => {
  if (editingSentenceId.value === sentence.sentence_id) {
    // æ”¶èµ·ç¼–è¾‘æ—¶ï¼Œä¼šæ£€æŸ¥æ˜¯å¦æœ‰æœªä¿å­˜çš„ä¿®æ”¹
    await closeEditing()
    return
  }
  
  // å¦‚æœæ­£åœ¨ç¼–è¾‘å…¶ä»–æ‹†å¥ï¼Œå…ˆæ£€æŸ¥æ˜¯å¦æœ‰æœªä¿å­˜çš„ä¿®æ”¹
  if (editingSentenceId.value && editingSentenceId.value !== sentence.sentence_id) {
    if (hasUnsavedChanges()) {
      try {
        await ElMessageBox.confirm(
          'å½“å‰æœ‰æœªä¿å­˜çš„è®¾ç½®ï¼Œæ˜¯å¦ä¿å­˜ï¼Ÿ',
          'æç¤º',
          {
            confirmButtonText: 'ä¿å­˜',
            cancelButtonText: 'å–æ¶ˆ',
            type: 'warning',
            distinguishCancelAndClose: true
          }
        )
        
        // ç”¨æˆ·ç‚¹å‡»äº†"ä¿å­˜"
        await handleSaveCurrent()
        // ä¿å­˜æˆåŠŸåç»§ç»­æ‰“å¼€æ–°çš„ç¼–è¾‘
      } catch (error) {
        // ç”¨æˆ·ç‚¹å‡»äº†"å–æ¶ˆ"ï¼Œä¸åˆ‡æ¢ç¼–è¾‘
        if (error === 'cancel') {
          return
        }
      }
    }
  }

  // å¼€å§‹ç¼–è¾‘æ—¶ï¼Œå¦‚æœè¿˜æ²¡æœ‰å¤‡ä»½ï¼Œåˆ›å»ºå¤‡ä»½
  if (!backupSentences.value) {
    createBackup()
  }

  editingSentenceId.value = sentence.sentence_id
  
  // ä»æ¥å£æ•°æ®ä¸­è·å–æ–­å¥åˆ—è¡¨ï¼ˆä½¿ç”¨æ¥å£çš„ breakingSentence æ•°æ®ï¼‰
  const breakingSentences = getBreakingSentencesFromApi(sentence.sentence_id)
  
  // æ£€æŸ¥æ˜¯å¦æœ‰å­å¥å­ï¼ˆç¼–è¾‘åŒºåŸŸåªæ˜¾ç¤ºå­å¥å­ï¼‰
  const children = breakingSentences
  
  // å¦‚æœæ²¡æœ‰å­å¥å­ï¼Œé»˜è®¤è¿›å…¥"å¤§ç¬¦å·æ¨¡å¼"ï¼šåˆ›å»ºä¸€ä¸ªå­å¥å­ï¼Œå†…å®¹æ˜¯çˆ¶å¥å­çš„å†…å®¹
  if (children.length === 0) {
    const newSentence = insertSentenceAfterLocal(sentence.sentence_id, {
      content: sentence.content,
      parent_id: sentence.sentence_id
    })

    if (newSentence && newSentence.sentence_id) {
      ensurePolyphonicState(newSentence.sentence_id)
      editingSubSentenceId.value = newSentence.sentence_id
      await loadSentenceDetail(newSentence.sentence_id, newSentence.content)
      selectSubSentence(newSentence)
      return
    }
  }
  
  // å¦‚æœæœ‰å­å¥å­ï¼Œé€‰ä¸­ç¬¬ä¸€ä¸ªå­å¥å­
  if (children.length > 0) {
    const firstChild = children.sort((a, b) => (a.display_order || 0) - (b.display_order || 0))[0]
    editingSubSentenceId.value = firstChild.sentence_id
    await loadSentenceDetail(firstChild.sentence_id, firstChild.content)
    selectSubSentence(firstChild)
  } else {
    // å¦‚æœæ²¡æœ‰å­å¥å­ä¸”åˆ›å»ºå¤±è´¥ï¼Œä½¿ç”¨çˆ¶å¥å­ï¼ˆè™½ç„¶ä¸ä¼šæ˜¾ç¤ºåœ¨ç¼–è¾‘åŒºåŸŸï¼‰
    editingSubSentenceId.value = sentence.sentence_id
    await loadSentenceDetail(sentence.sentence_id, sentence.content)
    selectSubSentence(sentence)
  }
}

// æ£€æŸ¥å½“å‰æ•°æ®ä¸å¤‡ä»½æ•°æ®æ˜¯å¦ä¸€è‡´
const hasUnsavedChanges = () => {
  if (!editingSentenceId.value || !backupSentences.value) {
    return false
  }
  
  // è·å–å½“å‰æ‹†å¥ä¸‹çš„æ‰€æœ‰æ–­å¥
  const currentBreakingSentences = getSubSentences(editingSentenceId.value)
    .filter(sub => sub.parent_id !== 0)
  
  // ä»å¤‡ä»½ä¸­è·å–å¯¹åº”çš„æ–­å¥
  const backupSentence = backupSentences.value.find(s => s.sentence_id === editingSentenceId.value)
  if (!backupSentence) {
    return false
  }
  
  const backupBreakingSentences = backupSentences.value
    .filter(sub => sub.parent_id === editingSentenceId.value && sub.parent_id !== 0)
  
  // æ¯”è¾ƒæ•°é‡
  if (currentBreakingSentences.length !== backupBreakingSentences.length) {
    return true
  }
  
  // æ¯”è¾ƒæ¯ä¸ªæ–­å¥çš„æ•°æ®
  for (const current of currentBreakingSentences) {
    const backup = backupBreakingSentences.find(b => b.sentence_id === current.sentence_id)
    
    if (!backup) {
      return true // æ–°å¢äº†æ–­å¥
    }
    
    // æ¯”è¾ƒå…³é”®å­—æ®µ
    if (current.content !== backup.content ||
        current.voice !== backup.voice ||
        current.volume !== backup.volume ||
        current.speed !== backup.speed) {
      return true
    }
    
    // æ¯”è¾ƒ pauseMarkers
    const currentPauseMarkers = JSON.stringify((current.pauseMarkers || []).sort((a, b) => a.location - b.location))
    const backupPauseMarkers = JSON.stringify((backup.pauseMarkers || []).sort((a, b) => a.location - b.location))
    if (currentPauseMarkers !== backupPauseMarkers) {
      return true
    }
    
    // æ¯”è¾ƒ polyphonicOverrides
    const currentPolyphonic = JSON.stringify((current.polyphonicOverrides || []).sort((a, b) => a.begin - b.begin))
    const backupPolyphonic = JSON.stringify((backup.polyphonicOverrides || []).sort((a, b) => a.begin - b.begin))
    if (currentPolyphonic !== backupPolyphonic) {
      return true
    }
    
    // æ¯”è¾ƒ speedSegments
    const currentSpeedSegments = JSON.stringify((current.speedSegments || []).sort((a, b) => a.begin - b.begin))
    const backupSpeedSegments = JSON.stringify((backup.speedSegments || []).sort((a, b) => a.begin - b.begin))
    if (currentSpeedSegments !== backupSpeedSegments) {
      return true
    }
  }
  
  // æ£€æŸ¥æ˜¯å¦æœ‰æ–­å¥è¢«åˆ é™¤
  for (const backup of backupBreakingSentences) {
    const current = currentBreakingSentences.find(c => c.sentence_id === backup.sentence_id)
    if (!current) {
      return true // åˆ é™¤äº†æ–­å¥
    }
  }
  
  return false
}

const closeEditing = async () => {
  // æ£€æŸ¥æ˜¯å¦æœ‰æœªä¿å­˜çš„ä¿®æ”¹
  if (hasUnsavedChanges()) {
    try {
      await ElMessageBox.confirm(
        'å½“å‰æœ‰æœªä¿å­˜çš„è®¾ç½®ï¼Œæ˜¯å¦ä¿å­˜ï¼Ÿ',
        'æç¤º',
        {
          confirmButtonText: 'ä¿å­˜',
          cancelButtonText: 'å–æ¶ˆ',
          type: 'warning',
          distinguishCancelAndClose: true
        }
      )
      
      // ç”¨æˆ·ç‚¹å‡»äº†"ä¿å­˜"
      await handleSaveCurrent()
      // ä¿å­˜æˆåŠŸåä¼šåˆ·æ–°æ•°æ®ï¼Œè¿™é‡Œç›´æ¥æ”¶èµ·ç¼–è¾‘åŒºåŸŸ
      editingSentenceId.value = null
      editingSubSentenceId.value = null
      hidePolyphonicTooltip()
    } catch (error) {
      // ç”¨æˆ·ç‚¹å‡»äº†"å–æ¶ˆ"æˆ–å…³é—­ï¼Œä¸åšä»»ä½•æ“ä½œ
      if (error === 'cancel') {
        return // ä¸æ”¶èµ·ç¼–è¾‘åŒºåŸŸ
      }
    }
  } else {
    editingSentenceId.value = null
    editingSubSentenceId.value = null
    hidePolyphonicTooltip()
  }
}

const loadSentenceDetail = async (sentenceId, fallbackContent = '') => {
  try {
    // ä»åŸå§‹æ•°æ®ä¸­æŸ¥æ‰¾æ–­å¥ä¿¡æ¯
    let detail = null
    
    // å…¼å®¹ä¸¤ç§æ•°æ®ç»“æ„ï¼š{ list: [...] } æˆ– { data: { list: [...] } }
    const listData = originalSentenceListData.value
    const sentenceList = listData?.list || listData?.data?.list
    
    if (sentenceList && Array.isArray(sentenceList)) {
      // éå†æ‰€æœ‰æ‹†å¥ï¼ŒæŸ¥æ‰¾å¯¹åº”çš„æ–­å¥
      for (const originalSentence of sentenceList) {
        if (Array.isArray(originalSentence.breakingSentenceList)) {
          const breakingSentence = originalSentence.breakingSentenceList.find(
            bs => bs.breakingSentenceId == sentenceId || String(bs.breakingSentenceId) === String(sentenceId)
          )
          
          if (breakingSentence) {
            const setting = breakingSentence.setting || {}
            
            // ä» setting ä¸­æå–æ•°æ®
            detail = {
              content: breakingSentence.content || setting.content || fallbackContent,
              voice: setting.voiceId || 'default',
              volume: convertVolumeFromApi(setting.volume), // æ¥å£èŒƒå›´ 90~240ï¼Œè½¬æ¢ä¸ºå‰ç«¯èŒƒå›´ 0~100
              speed: mapSpeedFromSetting(setting), // ä» setting ä¸­æ˜ å°„è¯­é€Ÿ
              pitch: 50 // API ä¸­æ²¡æœ‰ pitch å­—æ®µï¼Œä½¿ç”¨é»˜è®¤å€¼
            }
            break
          }
        }
        
        // å¦‚æœæ²¡æ‰¾åˆ°æ–­å¥ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯æ‹†å¥æœ¬èº«
        if (originalSentence.originalSentenceId == sentenceId || String(originalSentence.originalSentenceId) === String(sentenceId)) {
          detail = {
            content: originalSentence.content || fallbackContent,
            voice: 'default',
            volume: 70,
            speed: 0,
            pitch: 50
          }
          break
        }
      }
    }
    
    // å¦‚æœä»åŸå§‹æ•°æ®ä¸­æ‰¾ä¸åˆ°ï¼Œä½¿ç”¨ fallback
    if (!detail) {
      detail = {
        content: fallbackContent,
        voice: 'default',
        volume: 70,
        speed: 0,
        pitch: 50
      }
    }
    
    editingForm.sentenceId = sentenceId
    editingForm.content = detail.content
    editingForm.voice = detail.voice
    editingForm.volume = clampVolume(detail.volume)
    editingForm.speed = clampSpeed(detail.speed)
    editingForm.pitch = detail.pitch
  } catch (error) {
    console.error('åŠ è½½å¥å­è¯¦æƒ…å¤±è´¥:', error)
    editingForm.sentenceId = sentenceId
    editingForm.content = fallbackContent
    editingForm.voice = 'default'
    editingForm.volume = 70
    editingForm.speed = 0
    editingForm.pitch = 50
  }
}

// åˆå§‹åŒ– sentenceControllerï¼ˆåœ¨æ‰€æœ‰ä¾èµ–å‡½æ•°å®šä¹‰åï¼‰
sentenceController = new SentenceController({
  sentences,
  findSentenceById,
  generateNewSentenceId,
  originalSentenceListData,
  insertAfter: insertSentenceAfterLocal,
  // ä¿å­˜ç›¸å…³çš„æ–¹æ³•
  getSubSentences,
  setConfigApi: setConfig,
  createBackup,
  refreshSentences,
  loadSentenceDetail,
  selectSubSentence
})

// ä»æ¥å£éŸ³é‡å€¼è½¬æ¢ä¸ºå‰ç«¯éŸ³é‡å€¼
// æ¥å£èŒƒå›´ï¼š90~240ï¼Œå‰ç«¯èŒƒå›´ï¼š0~100
const convertVolumeFromApi = (apiVolume) => {
  if (typeof apiVolume !== 'number' || Number.isNaN(apiVolume)) return 70
  // å…¬å¼: volume_frontend = ((volume_api - 90) / 150) * 100
  const clamped = Math.max(90, Math.min(240, apiVolume))
  return Math.round(((clamped - 90) / 150) * 100)
}

// ä» setting ä¸­æ˜ å°„è¯­é€Ÿ
// å¦‚æœ setting ä¸­æœ‰ speed å­—æ®µï¼ˆ50~200ï¼‰ï¼Œè½¬æ¢ä¸ºå‰ç«¯èŒƒå›´ï¼ˆ-10~10ï¼‰
// å¦‚æœæ²¡æœ‰ï¼Œè¿”å›é»˜è®¤å€¼ 0
const mapSpeedFromSetting = (setting) => {
  if (!setting || typeof setting.speed !== 'number') return 0
  // 100 å¯¹åº” 0ï¼Œ50 å¯¹åº” -10ï¼Œ200 å¯¹åº” 10
  return Math.round(((setting.speed - 100) / 100) * 10)
}

const selectVoice = (voice) => {
  editingForm.voice = voice
}

const handleUpdateCategory = (value) => {
  activeVoiceCategory.value = value
}

const handleSaveCurrent = async () => {
  if (!editingSentenceId.value) {
    ElMessage.warning('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ‹†å¥è¿›è¡Œç¼–è¾‘')
    return
  }
  
  // éªŒè¯ editingSentenceId å¯¹åº”çš„å¥å­æ˜¯å¦å­˜åœ¨
  const rootSentence = findSentenceById(editingSentenceId.value)
  if (!rootSentence) {
    ElMessage.error('æœªæ‰¾åˆ°è¦ä¿å­˜çš„æ‹†å¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•')
    return
  }
  
  console.log('ğŸ” [handleSaveCurrent] å¼€å§‹ä¿å­˜', {
    editingSentenceId: editingSentenceId.value,
    editingSentenceIdType: typeof editingSentenceId.value,
    editingFormSentenceId: editingForm.sentenceId,
    rootSentence: {
      sentence_id: rootSentence.sentence_id,
      parent_id: rootSentence.parent_id
    }
  })
  
  try {
    // ä¿å­˜å½“å‰çš„ç¼–è¾‘çŠ¶æ€ï¼Œä»¥ä¾¿åˆ·æ–°åæ¢å¤
    const savedEditingSentenceId = editingSentenceId.value
    const savedEditingSubSentenceId = editingSubSentenceId.value
    
    // è°ƒç”¨ controller çš„ä¿å­˜æ–¹æ³•
    await sentenceController.saveCurrent({
      editingSentenceId: editingSentenceId.value,
      editingForm,
      editorRefs,
      polyphonicStateMap,
      taskId: taskId.value,
      onSuccess: async () => {
        ElMessage.success('ä¿å­˜æˆåŠŸ')
        
        // åˆ·æ–°æ•°æ®ï¼ˆä»æœåŠ¡å™¨è·å–æœ€æ–°æ•°æ®ï¼Œç¡®ä¿æ•°æ®ä¸€è‡´æ€§ï¼‰
        // ä¼ å…¥ preserveEditingState=true è¡¨ç¤ºä¿æŒç¼–è¾‘çŠ¶æ€
        await refreshSentences(true)
        
        // æ¢å¤ç¼–è¾‘çŠ¶æ€ï¼Œä¿æŒç•Œé¢å±•å¼€å’Œé€‰ä¸­çŠ¶æ€ä¸å˜
        if (savedEditingSentenceId) {
          // savedEditingSentenceId æ¥è‡ª toggleEditï¼Œä¸€å®šæ˜¯æ‹†å¥ï¼Œç›´æ¥ä½¿ç”¨
          editingSentenceId.value = savedEditingSentenceId
          
          // å¦‚æœä¹‹å‰æœ‰é€‰ä¸­çš„æ–­å¥ï¼Œå°è¯•æ¢å¤é€‰ä¸­çŠ¶æ€
          if (savedEditingSubSentenceId) {
            console.log('ğŸ”„ [handleSaveCurrent] å°è¯•æ¢å¤é€‰ä¸­çš„æ–­å¥', {
              savedEditingSubSentenceId,
              isLocalId: typeof savedEditingSubSentenceId === 'string' && savedEditingSubSentenceId.startsWith('local-')
            })
            
            const subSentence = findSentenceById(savedEditingSubSentenceId)
            if (subSentence) {
              console.log('âœ… [handleSaveCurrent] æ‰¾åˆ°æ–­å¥ï¼Œæ¢å¤é€‰ä¸­çŠ¶æ€', {
                sentenceId: subSentence.sentence_id,
                content: subSentence.content
              })
              editingSubSentenceId.value = savedEditingSubSentenceId
              await loadSentenceDetail(savedEditingSubSentenceId, subSentence.content)
              selectSubSentence(subSentence)
            } else {
              // å¦‚æœæ–­å¥ä¸å­˜åœ¨äº†ï¼ˆå¯èƒ½æ˜¯æœ¬åœ° ID è¢«æ›¿æ¢äº†ï¼‰ï¼Œå°è¯•é€šè¿‡å†…å®¹åŒ¹é…æ‰¾åˆ°æ–°çš„æ–­å¥
              console.log('âš ï¸ [handleSaveCurrent] æœªæ‰¾åˆ°æ–­å¥ï¼Œå°è¯•é€šè¿‡å†…å®¹åŒ¹é…', {
                savedEditingSubSentenceId,
                savedEditingSentenceId,
                savedContent: editingForm.content
              })
              
              // å¦‚æœæ˜¯æœ¬åœ° IDï¼Œå°è¯•é€šè¿‡å†…å®¹åŒ¹é…æ‰¾åˆ°å¯¹åº”çš„æ–°æ–­å¥
              if (typeof savedEditingSubSentenceId === 'string' && savedEditingSubSentenceId.startsWith('local-')) {
                const savedContent = editingForm.content
                const rootSentence = findSentenceById(savedEditingSentenceId)
                if (rootSentence && savedContent) {
                  // åœ¨åˆ·æ–°åçš„æ•°æ®ä¸­æŸ¥æ‰¾å†…å®¹åŒ¹é…çš„æ–­å¥
                  const allSubSentences = getSubSentences(savedEditingSentenceId).filter(sub => sub.parent_id !== 0)
                  const matchedSubSentence = allSubSentences.find(sub => sub.content === savedContent)
                  
                  if (matchedSubSentence) {
                    console.log('âœ… [handleSaveCurrent] é€šè¿‡å†…å®¹åŒ¹é…æ‰¾åˆ°æ–°æ–­å¥', {
                      oldId: savedEditingSubSentenceId,
                      newId: matchedSubSentence.sentence_id,
                      content: matchedSubSentence.content
                    })
                    editingSubSentenceId.value = matchedSubSentence.sentence_id
                    await loadSentenceDetail(matchedSubSentence.sentence_id, matchedSubSentence.content)
                    selectSubSentence(matchedSubSentence)
                  } else {
                    console.warn('âš ï¸ [handleSaveCurrent] æ— æ³•é€šè¿‡å†…å®¹åŒ¹é…æ‰¾åˆ°æ–°æ–­å¥ï¼Œé€‰ä¸­æ‹†å¥æœ¬èº«')
                    // å¦‚æœæ‰¾ä¸åˆ°ï¼Œé€‰ä¸­æ‹†å¥æœ¬èº«
                    const current = findSentenceById(savedEditingSentenceId)
                    if (current) {
                      editingSubSentenceId.value = savedEditingSentenceId
                      await loadSentenceDetail(savedEditingSentenceId, current.content)
                      selectSubSentence(current)
                    }
                  }
                } else {
                  // å¦‚æœæ‰¾ä¸åˆ°ï¼Œé€‰ä¸­æ‹†å¥æœ¬èº«
                  const current = findSentenceById(savedEditingSentenceId)
                  if (current) {
                    editingSubSentenceId.value = savedEditingSentenceId
                    await loadSentenceDetail(savedEditingSentenceId, current.content)
                    selectSubSentence(current)
                  }
                }
              } else {
                // å¦‚æœæ–­å¥ä¸å­˜åœ¨äº†ï¼Œé€‰ä¸­æ‹†å¥æœ¬èº«
                const current = findSentenceById(savedEditingSentenceId)
                if (current) {
                  editingSubSentenceId.value = savedEditingSentenceId
                  await loadSentenceDetail(savedEditingSentenceId, current.content)
                  selectSubSentence(current)
                }
              }
            }
          } else {
            // å¦‚æœæ²¡æœ‰é€‰ä¸­çš„æ–­å¥ï¼Œé€‰ä¸­æ‹†å¥æœ¬èº«
            const current = findSentenceById(savedEditingSentenceId)
            if (current) {
              editingSubSentenceId.value = savedEditingSentenceId
              await loadSentenceDetail(savedEditingSentenceId, current.content)
              selectSubSentence(current)
            }
          }
        }
      }
    })
  } catch (error) {
    console.error('ä¿å­˜å¤±è´¥:', error)
    ElMessage.error('ä¿å­˜å¤±è´¥ï¼Œè¯·é‡è¯•')
  }
}

const removeLocalSentence = (sentenceId) => {
  const index = sentences.value.findIndex((item) => item.sentence_id === sentenceId)
  if (index === -1) return null
  const [removed] = sentences.value.splice(index, 1)

  if (!removed.parent_id || removed.parent_id === 0) {
    for (let i = sentences.value.length - 1; i >= 0; i -= 1) {
      if (sentences.value[i].parent_id === removed.sentence_id) {
        sentences.value.splice(i, 1)
      }
    }
  }

  delete polyphonicStateMap[sentenceId]
  delete polyphonicModeMap[sentenceId]
  delete pauseEligibilityMap[sentenceId]
  delete selectionStateMap[sentenceId]
  delete editorRefs[sentenceId]
  return removed
}

const handleDelete = async (sentenceId) => {
  try {
    await ElMessageBox.confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå¥å­å—ï¼Ÿ', 'æç¤º', {
      confirmButtonText: 'ç¡®å®š',
      cancelButtonText: 'å–æ¶ˆ',
      type: 'warning'
    })
    
    // åˆ¤æ–­æ˜¯æ‹†å¥è¿˜æ˜¯æ–­å¥
    const sentence = findSentenceById(sentenceId)
    const isBreakingSentence = sentence && sentence.parent_id && sentence.parent_id !== 0
    
    if (isBreakingSentence) {
      // æ–­å¥ï¼šåªåœ¨å‰ç«¯æœ¬åœ°åˆ é™¤ï¼Œä¸è°ƒç”¨æ¥å£
      const removed = removeLocalSentence(sentenceId)
      
      if (removed && editingSubSentenceId.value === sentenceId) {
        const siblings = sentences.value
          .filter((item) => item.parent_id === removed.parent_id && item.parent_id !== 0)
          .sort((a, b) => (a.display_order || 0) - (b.display_order || 0))

        if (siblings.length > 0) {
          const next = siblings[0]
          editingSubSentenceId.value = next.sentence_id
          selectSubSentence(next)
        } else {
          editingSubSentenceId.value = null
          editingForm.sentenceId = ''
          editingForm.content = ''
        }
      }
      
      ElMessage.success('å·²åˆ é™¤ï¼ˆæœ¬åœ°ï¼‰')
    } else {
      // æ‹†å¥ï¼šè°ƒç”¨æ¥å£åˆ é™¤
      await deleteSentenceApi(sentenceId)
      ElMessage.success('åˆ é™¤æˆåŠŸ')

      const removed = removeLocalSentence(sentenceId)

      if (removed && editingSubSentenceId.value === sentenceId) {
        const siblings = sentences.value
          .filter((item) => item.parent_id === removed.parent_id && item.parent_id !== 0)
          .sort((a, b) => (a.display_order || 0) - (b.display_order || 0))

        if (siblings.length > 0) {
          const next = siblings[0]
          editingSubSentenceId.value = next.sentence_id
          selectSubSentence(next)
        } else {
          editingSubSentenceId.value = null
          editingForm.sentenceId = ''
          editingForm.content = ''
        }
      }
    }
  } catch (error) {
    if (error !== 'cancel') {
      console.error('åˆ é™¤å¤±è´¥:', error)
    }
  }
}

/**
 * å‘ä¸‹æ’å…¥æ–­å¥
 * 
 * ä¸šåŠ¡é€»è¾‘ï¼š
 * 1. åªèƒ½ä»æ–­å¥ç‚¹å‡»ï¼ˆæ‹†å¥æ²¡æœ‰è¿™ä¸ªæŒ‰é’®ï¼‰
 * 2. æ–°æ–­å¥çš„ parent_id æ°¸è¿œä½¿ç”¨å½“å‰æ‹†å¥çš„ IDï¼ˆå³ç‚¹å‡»çš„æ–­å¥çš„ parent_idï¼‰
 * 3. æ–°æ–­å¥æ’å…¥åœ¨ç‚¹å‡»çš„æ–­å¥ä¸‹æ–¹ï¼ˆæŒ‰ display_order æ’åºåçš„ä¸‹ä¸€ä¸ªä½ç½®ï¼‰
 * 4. æ’å…¥åé‡æ–°æ•´ç†æ‰€æœ‰æ–­å¥çš„ display_orderï¼ˆä» 0 å¼€å§‹è¿ç»­é€’å¢ï¼‰
 * 5. æ–°æ–­å¥çš„ ID ä½¿ç”¨ç»Ÿä¸€çš„ ID ç”Ÿæˆå™¨ï¼ˆ-1, -2, -3...ï¼‰
 * 
 * @param {number|string} sentenceId - ç‚¹å‡»çš„æ–­å¥ ID
 */
const handleInsertAfter = async (sentenceId) => {
  try {
    // æ­¥éª¤1ï¼šè·å–ç”¨æˆ·è¾“å…¥çš„æ–‡æœ¬
    const { value } = await ElMessageBox.prompt('è¯·è¾“å…¥è¦æ’å…¥çš„æ–‡æœ¬', 'å‘ä¸‹æ’å…¥', {
      confirmButtonText: 'ç¡®å®š',
      cancelButtonText: 'å–æ¶ˆ',
      inputPlaceholder: 'è¯·è¾“å…¥æ–‡æœ¬'
    })

    // æ­¥éª¤2ï¼šä½¿ç”¨æ§åˆ¶å™¨å¤„ç†å‘ä¸‹æ’å…¥çš„æ•°æ®é€»è¾‘
    const clickedSentence = findSentenceById(sentenceId)
    const newSentence = sentenceController.insertAfter(sentenceId, value)

    // æ­¥éª¤3ï¼šå¤„ç†æ–°æ–­å¥çš„çŠ¶æ€
    if (newSentence && newSentence.sentence_id) {
      ensurePolyphonicState(newSentence.sentence_id)

      // å¦‚æœå½“å‰æ­£åœ¨ç¼–è¾‘è¯¥æ‹†å¥ï¼Œè‡ªåŠ¨é€‰ä¸­æ–°æ’å…¥çš„æ–­å¥
      const rootId = clickedSentence.parent_id
      if (editingSentenceId.value === rootId && newSentence.parent_id === rootId) {
        selectSubSentence(newSentence)
      }

      ElMessage.success('æ’å…¥æˆåŠŸ')
    }
  } catch (error) {
    if (error !== 'cancel') {
      console.error('æ’å…¥å¤±è´¥:', error)
      ElMessage.error(error.message || 'æ’å…¥å¤±è´¥')
    }
  }
}

// è·å–æ‹†å¥çš„åˆæˆçŠ¶æ€
const getOriginalSentenceSynthesisStatus = (originalSentenceId) => {
  const status = originalSentenceStatus.value[originalSentenceId]
  if (!status) return 'pending'
  return status.status || 'pending'
}

// åˆæˆæ‹†å¥ï¼ˆæ ¹å¥å­ï¼‰
const handleResynthesizeOriginalSentence = async (originalSentenceId) => {
  try {
    // è°ƒç”¨åˆæˆæ‹†å¥æ¥å£
    await synthesizeOriginalSentence({ originalSentenceId: String(originalSentenceId) })
    ElMessage.success('åˆæˆä¸­ï¼Œè¯·ç¨å€™...')
    
    // æ›´æ–°çŠ¶æ€ä¸ºåˆæˆä¸­
    if (!originalSentenceStatus.value[originalSentenceId]) {
      originalSentenceStatus.value[originalSentenceId] = {
        status: 'processing',
        audioUrlList: [],
        timer: null
      }
    } else {
      originalSentenceStatus.value[originalSentenceId].status = 'processing'
    }
    
    // å¯åŠ¨è½®è¯¢ï¼Œæ˜¾ç¤ºé®ç½©ï¼ˆç±»ä¼¼åˆæˆå…¨éƒ¨éŸ³é¢‘ï¼‰
    startPollingOriginalSentenceStatus(originalSentenceId, true)
  } catch (error) {
    console.error('åˆæˆæ‹†å¥å¤±è´¥:', error)
    ElMessage.error('åˆæˆå¤±è´¥ï¼Œè¯·é‡è¯•')
    if (originalSentenceStatus.value[originalSentenceId]) {
      originalSentenceStatus.value[originalSentenceId].status = 'failed'
    }
    // å¦‚æœé®ç½©å·²æ˜¾ç¤ºï¼Œå…³é—­å®ƒ
    if (taskSynthesisProgress.value.visible) {
      taskSynthesisProgress.value.visible = false
    }
  }
}

// å¯åŠ¨è½®è¯¢æ‹†å¥åˆæˆçŠ¶æ€
const startPollingOriginalSentenceStatus = (originalSentenceId, showProgressDialog = false) => {
  // åˆå§‹åŒ–çŠ¶æ€
  if (!originalSentenceStatus.value[originalSentenceId]) {
    originalSentenceStatus.value[originalSentenceId] = {
      status: 'processing',
      audioUrlList: [],
      timer: null,
      total: 0,
      completed: 0,
      pending: 0,
      progress: 0
    }
  }
  
  // å¦‚æœéœ€è¦æ˜¾ç¤ºé®ç½©ï¼Œæ˜¾ç¤ºå®ƒ
  if (showProgressDialog) {
    taskSynthesisProgress.value.visible = true
    taskSynthesisProgress.value.status = 'processing'
  }
  
  startPollingSynthesisStatus({
    getStatusApi: () => getOriginalSentenceStatus(originalSentenceId),
    progressState: originalSentenceStatus.value[originalSentenceId],
    onCompleted: (data) => {
      const statusInfo = originalSentenceStatus.value[originalSentenceId]
      statusInfo.status = 'completed'
      statusInfo.audioUrlList = (data.audioUrlList || []).sort((a, b) => (a.sequence || 0) - (b.sequence || 0))
      
      // å¦‚æœæ˜¾ç¤ºäº†é®ç½©ï¼Œå…³é—­å®ƒ
      if (showProgressDialog) {
        setTimeout(() => {
          taskSynthesisProgress.value.visible = false
          ElMessage.success('åˆæˆå®Œæˆ')
        }, 1000)
      } else {
        ElMessage.success('åˆæˆå®Œæˆ')
      }
    },
    onFailed: (data) => {
      const statusInfo = originalSentenceStatus.value[originalSentenceId]
      statusInfo.status = 'failed'
      
      // å¦‚æœæ˜¾ç¤ºäº†é®ç½©ï¼Œå…³é—­å®ƒ
      if (showProgressDialog) {
        setTimeout(() => {
          taskSynthesisProgress.value.visible = false
          ElMessage.error('åˆæˆå¤±è´¥')
        }, 2000)
      } else {
        ElMessage.error('åˆæˆå¤±è´¥')
      }
    },
    onProcessing: (data) => {
      const statusInfo = originalSentenceStatus.value[originalSentenceId]
      statusInfo.status = 'processing'
      // æ›´æ–°å·²å®Œæˆçš„éŸ³é¢‘åˆ—è¡¨
      if (data.audioUrlList && data.audioUrlList.length > 0) {
        statusInfo.audioUrlList = data.audioUrlList.sort((a, b) => (a.sequence || 0) - (b.sequence || 0))
      }
      
      // æ›´æ–°é®ç½©è¿›åº¦ï¼ˆå¦‚æœæ˜¾ç¤ºäº†é®ç½©ï¼‰
      if (showProgressDialog && data.total !== undefined) {
        taskSynthesisProgress.value.total = data.total || 0
        taskSynthesisProgress.value.completed = data.completed || 0
        taskSynthesisProgress.value.pending = data.pending || 0
        if (taskSynthesisProgress.value.total > 0) {
          taskSynthesisProgress.value.progress = Math.round(
            (taskSynthesisProgress.value.completed / taskSynthesisProgress.value.total) * 100
          )
        }
      }
    },
    parseStatusData: (statusData) => {
      // æ‹†å¥çŠ¶æ€æ•°æ®ç›´æ¥è¿”å›ï¼Œä¸éœ€è¦é¢å¤–è§£æ
      return statusData || {}
    }
  })
}

// æ’­æ”¾æ‹†å¥ï¼ˆæŒ‰é¡ºåºæ’­æ”¾å¤šä¸ªéŸ³é¢‘ï¼‰
const handlePlayOriginalSentence = async (sentence) => {
  const originalSentenceId = sentence.sentence_id
  
  // è·å–è¯¥æ‹†å¥çš„éŸ³é¢‘åˆ—è¡¨
  const statusInfo = originalSentenceStatus.value[originalSentenceId]
  if (!statusInfo || !statusInfo.audioUrlList || statusInfo.audioUrlList.length === 0) {
    ElMessage.warning('æš‚æ— éŸ³é¢‘å¯æ’­æ”¾')
    return
  }
  
  const audioUrlList = statusInfo.audioUrlList
  
  // å¦‚æœåªæœ‰ä¸€ä¸ªéŸ³é¢‘ï¼Œä½¿ç”¨å…¨å±€æ’­æ”¾å™¨
  if (audioUrlList.length === 1 && audioPlayer) {
    audioPlayer.show(audioUrlList[0].audioUrl)
    return
  }
  
  // å¤šä¸ªéŸ³é¢‘ï¼šä½¿ç”¨åŸæ¥çš„æ’­æ”¾æ–¹å¼ï¼ˆæŒ‰é¡ºåºæ’­æ”¾ï¼‰
  // åœæ­¢å½“å‰æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘
  stopAllPlayingAudio()
  
  // åˆ›å»ºéŸ³é¢‘å…ƒç´ æ•°ç»„
  const audioElements = audioUrlList.map((item, index) => {
    const audio = new Audio(item.audioUrl)
    audio.preload = 'auto'
    return { audio, sequence: item.sequence || index }
  })
  
  // æŒ‰ sequence æ’åº
  audioElements.sort((a, b) => a.sequence - b.sequence)
  
  // è®¾ç½®å½“å‰æ’­æ”¾ä¿¡æ¯
  currentPlayingAudio.value = {
    sentenceId: originalSentenceId,
    audioList: audioElements,
    currentIndex: 0,
    audioElements: audioElements.map(item => item.audio)
  }
  
  // æ’­æ”¾ç¬¬ä¸€ä¸ªéŸ³é¢‘
  playNextAudio(0)
}

// æ’­æ”¾ä¸‹ä¸€ä¸ªéŸ³é¢‘
const playNextAudio = (index) => {
  if (!currentPlayingAudio.value || index >= currentPlayingAudio.value.audioElements.length) {
    // æ’­æ”¾å®Œæˆ
    currentPlayingAudio.value = null
    return
  }
  
  const audio = currentPlayingAudio.value.audioElements[index]
  currentPlayingAudio.value.currentIndex = index
  
  // ç›‘å¬æ’­æ”¾ç»“æŸäº‹ä»¶
  const onEnded = () => {
    audio.removeEventListener('ended', onEnded)
    // æ’­æ”¾ä¸‹ä¸€ä¸ª
    playNextAudio(index + 1)
  }
  
  audio.addEventListener('ended', onEnded)
  
  // æ’­æ”¾å½“å‰éŸ³é¢‘
  audio.play().catch(error => {
    console.error('æ’­æ”¾éŸ³é¢‘å¤±è´¥:', error)
    ElMessage.error('æ’­æ”¾å¤±è´¥')
    currentPlayingAudio.value = null
  })
}

// åœæ­¢æ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„éŸ³é¢‘
const stopAllPlayingAudio = () => {
  if (currentPlayingAudio.value) {
    currentPlayingAudio.value.audioElements.forEach(audio => {
      audio.pause()
      audio.currentTime = 0
    })
    currentPlayingAudio.value = null
  }
  
  // åœæ­¢æ‰€æœ‰ audioRefs ä¸­çš„éŸ³é¢‘
  Object.values(audioRefs.value).forEach(audio => {
    if (audio && !audio.paused) {
      audio.pause()
      audio.currentTime = 0
    }
  })
}

// è·å–æ–­å¥çš„åˆæˆçŠ¶æ€ï¼ˆç›´æ¥ä»æ¥å£æ•°æ®ä¸­è·å–ï¼‰
const getBreakingSentenceSynthesisStatus = (breakingSentenceId) => {
  // æ–°æ’å…¥çš„æ–­å¥ï¼ˆID ä¸º -1ï¼‰ï¼Œç›´æ¥è¿”å› pending çŠ¶æ€
  if (breakingSentenceId === -1 || breakingSentenceId === '-1') {
    return { status: 'pending', audioUrl: '' }
  }
  
  // ä»æ¥å£æ•°æ®ä¸­æŸ¥æ‰¾å¯¹åº”çš„æ–­å¥
  const listData = originalSentenceListData.value
  const sentenceList = listData?.list || listData?.data?.list
  
  if (!sentenceList || !Array.isArray(sentenceList)) {
    return { status: 'pending', audioUrl: '' }
  }
  
  // éå†æ‰€æœ‰æ‹†å¥ï¼ŒæŸ¥æ‰¾å¯¹åº”çš„æ–­å¥
  for (const originalSentence of sentenceList) {
    if (!Array.isArray(originalSentence.breakingSentenceList)) continue
    
    const breakingSentence = originalSentence.breakingSentenceList.find(
      bs => bs.breakingSentenceId == breakingSentenceId || 
           String(bs.breakingSentenceId) === String(breakingSentenceId)
    )
    
    if (breakingSentence) {
      // æ˜ å°„ synthesisStatus: 0-æœªåˆæˆï¼Œ1-åˆæˆä¸­ï¼Œ2-å·²åˆæˆï¼Œ3-åˆæˆå¤±è´¥
      const statusMap = {
        0: 'pending',
        1: 'processing',
        2: 'completed',
        3: 'failed'
      }
      const status = statusMap[breakingSentence.synthesisStatus] || 'pending'
      const audioUrl = breakingSentence.audioUrl || ''
      
      return { status, audioUrl }
    }
  }
  
  // å¦‚æœæ‰¾ä¸åˆ°ï¼Œè¿”å›é»˜è®¤çŠ¶æ€
  return { status: 'pending', audioUrl: '' }
}

// åˆæˆæ–­å¥ï¼ˆå­å¥å­ï¼‰
const handleResynthesizeBreakingSentence = async (breakingSentenceId) => {
  try {
    // è°ƒç”¨åˆæˆæ–­å¥æ¥å£
    await synthesizeBreakingSentence({ breakingSentenceId })
    ElMessage.success('åˆæˆä¸­ï¼Œè¯·ç¨å€™...')
    
    // æ›´æ–°çŠ¶æ€ä¸ºåˆæˆä¸­
    if (!breakingSentenceStatus.value[breakingSentenceId]) {
      breakingSentenceStatus.value[breakingSentenceId] = {
        status: 'processing',
        audioUrl: '',
        timer: null
      }
    } else {
      breakingSentenceStatus.value[breakingSentenceId].status = 'processing'
    }
    
    // å¯åŠ¨è½®è¯¢
    startPollingBreakingSentenceStatus(breakingSentenceId)
  } catch (error) {
    console.error('åˆæˆæ–­å¥å¤±è´¥:', error)
    ElMessage.error('åˆæˆå¤±è´¥ï¼Œè¯·é‡è¯•')
    if (breakingSentenceStatus.value[breakingSentenceId]) {
      breakingSentenceStatus.value[breakingSentenceId].status = 'failed'
    }
  }
}

// å¯åŠ¨è½®è¯¢æ–­å¥åˆæˆçŠ¶æ€
const startPollingBreakingSentenceStatus = (breakingSentenceId) => {
  // åˆå§‹åŒ–çŠ¶æ€
  if (!breakingSentenceStatus.value[breakingSentenceId]) {
    breakingSentenceStatus.value[breakingSentenceId] = {
      status: 'processing',
      audioUrl: '',
      timer: null
    }
  }
  
  startPollingSynthesisStatus({
    getStatusApi: () => getBreakingSentenceStatus(breakingSentenceId),
    progressState: breakingSentenceStatus.value[breakingSentenceId],
    onCompleted: (data) => {
      const statusInfo = breakingSentenceStatus.value[breakingSentenceId]
      statusInfo.status = 'completed'
      statusInfo.audioUrl = data.audioUrl || ''
      ElMessage.success('åˆæˆå®Œæˆ')
    },
    onFailed: (data) => {
      const statusInfo = breakingSentenceStatus.value[breakingSentenceId]
      statusInfo.status = 'failed'
      ElMessage.error('åˆæˆå¤±è´¥')
    },
    onProcessing: (data) => {
      const statusInfo = breakingSentenceStatus.value[breakingSentenceId]
      statusInfo.status = 'processing'
      // å¦‚æœæœ‰éŸ³é¢‘URLï¼Œæ›´æ–°å®ƒ
      if (data.audioUrl) {
        statusInfo.audioUrl = data.audioUrl
      }
    },
    parseStatusData: (statusData) => {
      // æ–­å¥çŠ¶æ€æ•°æ®éœ€è¦è½¬æ¢ï¼šsynthesisStatus è½¬æ¢ä¸º status
      // synthesisStatus: 0-æœªåˆæˆï¼Œ1-åˆæˆä¸­ï¼Œ2-å·²åˆæˆï¼Œ3-åˆæˆå¤±è´¥
      const synthesisStatus = statusData.synthesisStatus
      let status = 'processing'
      if (synthesisStatus === 2) {
        status = 'completed'
      } else if (synthesisStatus === 3) {
        status = 'failed'
      } else if (synthesisStatus === 0) {
        status = 'pending'
      }
      
      return {
        ...statusData,
        status
      }
    }
  })
}

// å…¨éƒ¨åˆæˆï¼šåˆæˆå½“å‰æ‹†å¥ä¸‹çš„æ‰€æœ‰æ–­å¥
const handleSynthesizeAllBreakingSentences = async () => {
  if (!editingSentenceId.value) {
    ElMessage.warning('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ‹†å¥è¿›è¡Œç¼–è¾‘')
    return
  }
  
  try {
    // è°ƒç”¨åˆæˆæ‹†å¥æ¥å£ï¼ˆè¿™ä¼šåˆæˆæ‹†å¥ä¸‹çš„æ‰€æœ‰æ–­å¥ï¼‰
    await synthesizeOriginalSentence({ originalSentenceId: String(editingSentenceId.value) })
    ElMessage.success('åˆæˆä¸­ï¼Œè¯·ç¨å€™...')
    
    // è·å–å½“å‰æ‹†å¥ä¸‹çš„æ‰€æœ‰æ–­å¥
    const breakingSentences = getSubSentences(editingSentenceId.value)
      .filter(sub => sub.parent_id !== 0) // åªåŒ…å«æ–­å¥ï¼Œä¸åŒ…å«æ‹†å¥æœ¬èº«
    
    if (breakingSentences.length === 0) {
      ElMessage.warning('è¯¥æ‹†å¥ä¸‹æ²¡æœ‰æ–­å¥')
      return
    }
    
    // ä¸ºæ¯ä¸ªæ–­å¥å¯åŠ¨è½®è¯¢
    breakingSentences.forEach(breakingSentence => {
      const breakingSentenceId = breakingSentence.sentence_id
      
      // åˆå§‹åŒ–æ–­å¥çŠ¶æ€ä¸ºåˆæˆä¸­
      if (!breakingSentenceStatus.value[breakingSentenceId]) {
        breakingSentenceStatus.value[breakingSentenceId] = {
          status: 'processing',
          audioUrl: '',
          timer: null
        }
      } else {
        breakingSentenceStatus.value[breakingSentenceId].status = 'processing'
      }
      
      // å¯åŠ¨è½®è¯¢è¯¥æ–­å¥çš„åˆæˆçŠ¶æ€
      startPollingBreakingSentenceStatus(breakingSentenceId)
    })
  } catch (error) {
    console.error('å…¨éƒ¨åˆæˆå¤±è´¥:', error)
    ElMessage.error('åˆæˆå¤±è´¥ï¼Œè¯·é‡è¯•')
    
    // å°†æ‰€æœ‰æ–­å¥çŠ¶æ€è®¾ç½®ä¸ºå¤±è´¥
    const breakingSentences = getSubSentences(editingSentenceId.value)
      .filter(sub => sub.parent_id !== 0)
    breakingSentences.forEach(breakingSentence => {
      const breakingSentenceId = breakingSentence.sentence_id
      if (breakingSentenceStatus.value[breakingSentenceId]) {
        breakingSentenceStatus.value[breakingSentenceId].status = 'failed'
      }
    })
  }
}

// åŸæœ‰çš„ handleResynthesize ä¿ç•™ç”¨äºå…¼å®¹ï¼ˆå¦‚æœå…¶ä»–åœ°æ–¹è¿˜åœ¨ä½¿ç”¨ï¼‰
const handleResynthesize = async (sentenceId) => {
  // åˆ¤æ–­æ˜¯æ‹†å¥è¿˜æ˜¯æ–­å¥
  // å¦‚æœèƒ½åœ¨ sentences ä¸­æ‰¾åˆ°ä¸” parent_id === 0ï¼Œåˆ™æ˜¯æ‹†å¥
  const sentence = sentences.value.find(s => s.sentence_id === sentenceId)
  if (sentence && sentence.parent_id === 0) {
    // æ˜¯æ‹†å¥
    await handleResynthesizeOriginalSentence(sentenceId)
  } else {
    // æ˜¯æ–­å¥
    await handleResynthesizeBreakingSentence(sentenceId)
  }
}

const handlePlay = (sentence) => {
  console.log('ğŸµ [handlePlay] æ’­æ”¾æŒ‰é’®è¢«ç‚¹å‡»', {
    sentence,
    sentenceId: sentence.sentence_id,
    parentId: sentence.parent_id,
    hasAudioPlayer: !!audioPlayer,
    sentenceKeys: Object.keys(sentence)
  })
  
  // åˆ¤æ–­æ˜¯æ‹†å¥è¿˜æ˜¯æ–­å¥
  // ä» getBreakingSentencesFromApi è¿”å›çš„æ–­å¥éƒ½æœ‰ parent_idï¼Œä¸”ä¸ç­‰äº 0
  const isRootSentence = sentence.parent_id === 0 || !sentence.parent_id
  
  console.log('ğŸµ [handlePlay] åˆ¤æ–­ç»“æœ', {
    isRootSentence,
    parentId: sentence.parent_id,
    parentIdType: typeof sentence.parent_id
  })
  
  if (isRootSentence) {
    // æ‹†å¥ï¼šæŒ‰é¡ºåºæ’­æ”¾å¤šä¸ªéŸ³é¢‘
    console.log('ğŸµ [handlePlay] æ‹†å¥æ’­æ”¾')
    handlePlayOriginalSentence(sentence)
  } else {
    // æ–­å¥ï¼šæ’­æ”¾å•ä¸ªéŸ³é¢‘
    const breakingSentenceId = sentence.sentence_id
    const statusInfo = breakingSentenceStatus.value[breakingSentenceId]
    
    // å°è¯•å¤šç§æ–¹å¼è·å– audioUrl
    let audioUrl = statusInfo?.audioUrl || sentence.audio_url || sentence.audioUrl
    
    // å¦‚æœè¿˜æ˜¯æ²¡æœ‰ï¼Œå°è¯•ä»åŸå§‹æ•°æ®ä¸­æŸ¥æ‰¾
    if (!audioUrl) {
      const listData = originalSentenceListData.value
      const sentenceList = listData?.list || listData?.data?.list
      if (sentenceList && Array.isArray(sentenceList)) {
        for (const originalSentence of sentenceList) {
          if (Array.isArray(originalSentence.breakingSentenceList)) {
            const breakingSentence = originalSentence.breakingSentenceList.find(
              bs => bs.breakingSentenceId == breakingSentenceId || 
                    String(bs.breakingSentenceId) === String(breakingSentenceId)
            )
            if (breakingSentence) {
              audioUrl = breakingSentence.audioUrl
              break
            }
          }
        }
      }
    }
    
    console.log('ğŸµ [handlePlay] æ–­å¥æ’­æ”¾', {
      breakingSentenceId,
      statusInfo,
      audioUrl,
      sentenceAudioUrl: sentence.audio_url,
      sentenceAudioUrl2: sentence.audioUrl,
      hasAudioPlayer: !!audioPlayer,
      allStatusKeys: Object.keys(breakingSentenceStatus.value)
    })
    
    if (!audioUrl) {
      console.warn('âš ï¸ [handlePlay] æ²¡æœ‰éŸ³é¢‘URL', {
        breakingSentenceId,
        statusInfo,
        sentence
      })
      ElMessage.warning('æš‚æ— éŸ³é¢‘å¯æ’­æ”¾')
      return
    }
    
    // ä½¿ç”¨å…¨å±€éŸ³é¢‘æ’­æ”¾å™¨
    if (audioPlayer) {
      console.log('âœ… [handlePlay] ä½¿ç”¨å…¨å±€æ’­æ”¾å™¨æ’­æ”¾', { audioUrl })
      audioPlayer.show(audioUrl)
    } else {
      console.warn('âš ï¸ [handlePlay] audioPlayer æœªæ³¨å…¥ï¼Œä½¿ç”¨å›é€€æ–¹å¼')
      // å›é€€åˆ°åŸæ¥çš„æ’­æ”¾æ–¹å¼
      const audio = new Audio(audioUrl)
      audio.preload = 'auto'
      audio.play().catch(error => {
        console.error('æ’­æ”¾éŸ³é¢‘å¤±è´¥:', error)
        ElMessage.error('æ’­æ”¾å¤±è´¥')
      })
    }
  }
}

/**
 * é€šç”¨çš„åˆæˆçŠ¶æ€è½®è¯¢å‡½æ•°
 * @param {Object} config - è½®è¯¢é…ç½®
 * @param {Function} config.getStatusApi - è·å–çŠ¶æ€çš„APIå‡½æ•°
 * @param {Object|Ref} config.progressState - è¿›åº¦çŠ¶æ€å¯¹è±¡ï¼ˆå¯ä»¥æ˜¯ ref æˆ–æ™®é€šå¯¹è±¡ï¼‰
 * @param {Function} config.onCompleted - å®Œæˆå›è°ƒ
 * @param {Function} config.onFailed - å¤±è´¥å›è°ƒ
 * @param {Function} config.onProcessing - å¤„ç†ä¸­å›è°ƒï¼ˆå¯é€‰ï¼‰
 * @param {Function} config.parseStatusData - è§£æçŠ¶æ€æ•°æ®çš„å‡½æ•°ï¼ˆå¯é€‰ï¼‰
 * @param {Function} config.getProgressState - è·å–è¿›åº¦çŠ¶æ€çš„å‡½æ•°ï¼ˆå¯é€‰ï¼Œç”¨äºä»å¯¹è±¡ä¸­è·å–çŠ¶æ€ï¼‰
 */
const startPollingSynthesisStatus = ({
  getStatusApi,
  progressState,
  onCompleted,
  onFailed,
  onProcessing,
  parseStatusData,
  getProgressState
}) => {
  // è·å–çŠ¶æ€å¯¹è±¡çš„è¾…åŠ©å‡½æ•°
  const getState = () => {
    if (getProgressState) {
      return getProgressState()
    }
    // å¦‚æœæ˜¯ refï¼Œè¿”å› .valueï¼›å¦åˆ™ç›´æ¥è¿”å›
    return progressState.value !== undefined ? progressState.value : progressState
  }
  
  // è®¾ç½®çŠ¶æ€å¯¹è±¡çš„è¾…åŠ©å‡½æ•°
  const setState = (updates) => {
    const state = getState()
    Object.assign(state, updates)
  }
  
  // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
  const currentState = getState()
  if (currentState.timer) {
    clearInterval(currentState.timer)
  }
  
  const poll = async () => {
    try {
      const statusData = await getStatusApi()
      
      // å¦‚æœæä¾›äº†è‡ªå®šä¹‰è§£æå‡½æ•°ï¼Œä½¿ç”¨å®ƒï¼›å¦åˆ™ç›´æ¥ä½¿ç”¨è¿”å›çš„æ•°æ®
      const data = parseStatusData ? parseStatusData(statusData) : (statusData || {})
      
      const state = getState()
      
      // æ›´æ–°è¿›åº¦ä¿¡æ¯ï¼ˆå¦‚æœæ•°æ®ä¸­æœ‰è¿™äº›å­—æ®µï¼‰
      if (data.total !== undefined) {
        state.total = data.total || 0
      }
      if (data.completed !== undefined) {
        state.completed = data.completed || 0
      }
      if (data.pending !== undefined) {
        state.pending = data.pending || 0
      }
      
      // è®¡ç®—è¿›åº¦ç™¾åˆ†æ¯”
      if (state.total > 0) {
        state.progress = Math.round(
          (state.completed / state.total) * 100
        )
      } else if (data.progress !== undefined) {
        state.progress = data.progress || 0
      }
      
      // åˆ¤æ–­çŠ¶æ€
      const status = data.status
      const statusNum = Number(status)
      
      // åˆ¤æ–­æ˜¯å¦å®Œæˆï¼šstatus === 2ï¼ˆè¯­éŸ³åˆæˆæˆåŠŸï¼‰æˆ– progress >= 100 æˆ– completed >= total
      const isCompleted = status === 'completed' || 
                         statusNum === 2 || 
                         state.progress >= 100 ||
                         (state.total > 0 && 
                          state.completed >= state.total)
      
      // åˆ¤æ–­æ˜¯å¦å¤±è´¥ï¼šstatus === 3ï¼ˆè¯­éŸ³åˆæˆå¤±è´¥ï¼‰
      const isFailed = status === 'failed' || statusNum === 3
      
      console.log('ğŸ” [è½®è¯¢] çŠ¶æ€åˆ¤æ–­', {
        status,
        statusNum,
        isCompleted,
        isFailed,
        progress: state.progress,
        completed: state.completed,
        total: state.total,
        hasTimer: !!state.timer
      })
      
      if (isCompleted) {
        // åˆæˆå®Œæˆ
        setState({ status: 'completed', progress: 100 })
        
        // æ¸…é™¤å®šæ—¶å™¨ - éœ€è¦é‡æ–°è·å– stateï¼Œç¡®ä¿è·å–åˆ°æœ€æ–°çš„å®šæ—¶å™¨å¼•ç”¨
        const currentState = getState()
        if (currentState.timer) {
          console.log('ğŸ” [è½®è¯¢] æ¸…é™¤å®šæ—¶å™¨ï¼ˆå®Œæˆï¼‰', { timer: currentState.timer })
          clearInterval(currentState.timer)
          currentState.timer = null
        }
        
        // è°ƒç”¨å®Œæˆå›è°ƒ
        if (onCompleted) {
          onCompleted(data)
        }
      } else if (isFailed) {
        // åˆæˆå¤±è´¥
        setState({ status: 'failed' })
        
        // æ¸…é™¤å®šæ—¶å™¨ - éœ€è¦é‡æ–°è·å– stateï¼Œç¡®ä¿è·å–åˆ°æœ€æ–°çš„å®šæ—¶å™¨å¼•ç”¨
        const currentState = getState()
        if (currentState.timer) {
          console.log('ğŸ” [è½®è¯¢] æ¸…é™¤å®šæ—¶å™¨ï¼ˆå¤±è´¥ï¼‰', { timer: currentState.timer })
          clearInterval(currentState.timer)
          currentState.timer = null
        }
        
        // è°ƒç”¨å¤±è´¥å›è°ƒ
        if (onFailed) {
          onFailed(data)
        }
      } else {
        // ç»§ç»­åˆæˆä¸­
        setState({ status: 'processing' })
        
        // è°ƒç”¨å¤„ç†ä¸­å›è°ƒ
        if (onProcessing) {
          onProcessing(data)
        }
      }
    } catch (error) {
      console.error('è·å–åˆæˆçŠ¶æ€å¤±è´¥:', error)
      // å‡ºé”™æ—¶ä¸æ¸…é™¤å®šæ—¶å™¨ï¼Œç»§ç»­è½®è¯¢
    }
  }
  
  // è®¾ç½®å®šæ—¶å™¨ï¼Œæ¯500msè½®è¯¢ä¸€æ¬¡
  const timer = setInterval(() => {
    // åœ¨æ¯æ¬¡è½®è¯¢å‰æ£€æŸ¥çŠ¶æ€ï¼Œå¦‚æœå·²å®Œæˆæˆ–å¤±è´¥ï¼Œåœæ­¢è½®è¯¢
    const currentState = getState()
    if (currentState.status === 'completed' || currentState.status === 'failed') {
      if (currentState.timer) {
        console.log('ğŸ” [è½®è¯¢] æ£€æµ‹åˆ°å·²å®Œæˆ/å¤±è´¥çŠ¶æ€ï¼Œæ¸…é™¤å®šæ—¶å™¨', {
          status: currentState.status,
          timer: currentState.timer
        })
        clearInterval(currentState.timer)
        currentState.timer = null
      }
      return
    }
    poll()
  }, 500)
  
  const state = getState()
  state.timer = timer
  
  console.log('ğŸ” [è½®è¯¢] å¯åŠ¨å®šæ—¶å™¨', {
    timer,
    state: {
      status: state.status,
      progress: state.progress,
      hasTimer: !!state.timer
    }
  })
  
  // ç«‹å³æ‰§è¡Œä¸€æ¬¡
  poll()
}

// å¯åŠ¨ä»»åŠ¡åˆæˆè¿›åº¦è½®è¯¢
const startPollingTaskSynthesis = () => {
  // æ˜¾ç¤ºé®ç½©
  taskSynthesisProgress.value.visible = true
  taskSynthesisProgress.value.status = 'processing'
  
  startPollingSynthesisStatus({
    getStatusApi: () => getTaskStatus(parseInt(taskId.value)),
    progressState: taskSynthesisProgress,
    onCompleted: async (data) => {
      taskStatus.value = 2 // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸º 2ï¼ˆè¯­éŸ³åˆæˆæˆåŠŸï¼‰
      // å»¶è¿Ÿå…³é—­é®ç½©å¹¶åˆ·æ–°æ•°æ®
      setTimeout(async () => {
        taskSynthesisProgress.value.visible = false
        await refreshSentences()
        ElMessage.success('åˆæˆå®Œæˆ')
      }, 1000)
    },
    onFailed: (data) => {
      taskStatus.value = 3 // æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸º 3ï¼ˆè¯­éŸ³åˆæˆå¤±è´¥ï¼‰
      // å»¶è¿Ÿå…³é—­é®ç½©
      setTimeout(() => {
        taskSynthesisProgress.value.visible = false
        ElMessage.error('åˆæˆå¤±è´¥')
      }, 2000)
    }
  })
}

// åˆæˆå…¨éƒ¨éŸ³é¢‘
const handleSynthesizeAll = async () => {
  if (!taskId.value) {
    ElMessage.warning('ç¼ºå°‘ä»»åŠ¡ID')
    return
  }
  
  // æ£€æŸ¥æ˜¯å¦æœ‰æœªä¿å­˜çš„è®¾ç½®
  if (editingSentenceId.value && hasUnsavedChanges()) {
    try {
      await ElMessageBox.confirm(
        'å½“å‰æœ‰æœªä¿å­˜çš„è®¾ç½®ï¼Œè¯·å…ˆä¿å­˜åå†è¿›è¡Œåˆæˆæ“ä½œ',
        'æç¤º',
        {
          confirmButtonText: 'å»ä¿å­˜',
          cancelButtonText: 'å–æ¶ˆ',
          type: 'warning',
          distinguishCancelAndClose: true
        }
      )
      
      // ç”¨æˆ·ç‚¹å‡»äº†"å»ä¿å­˜"ï¼Œä¸è¿›è¡Œåˆæˆæ“ä½œ
      return
    } catch (error) {
      // ç”¨æˆ·ç‚¹å‡»äº†"å–æ¶ˆ"æˆ–å…³é—­ï¼Œä¸è¿›è¡Œåˆæˆæ“ä½œ
      return
    }
  }
  
  try {
    synthesizingAll.value = true
    await synthesizeTask({ taskId: parseInt(taskId.value) })
    
    // å¯åŠ¨è½®è¯¢
    startPollingTaskSynthesis()
  } catch (error) {
    console.error('åˆæˆå…¨éƒ¨éŸ³é¢‘å¤±è´¥:', error)
    ElMessage.error('åˆæˆå¤±è´¥ï¼Œè¯·é‡è¯•')
    synthesizingAll.value = false
  } finally {
    // æ³¨æ„ï¼šsynthesizingAll åœ¨è½®è¯¢å®Œæˆåä¸éœ€è¦é‡ç½®ï¼Œå› ä¸ºé®ç½©å·²ç»æ˜¾ç¤ºäº†
  }
}

// æ ¹æ®ä»»åŠ¡çŠ¶æ€è®¡ç®—æŒ‰é’®å¯ç”¨æ€§
const canSynthesizeAll = computed(() => {
  // status = 0ï¼ˆæ‹†å¥å®Œæˆï¼‰ï¼šå¯ç‚¹å‡»
  // status = 1ï¼ˆè¯­éŸ³åˆæˆä¸­ï¼‰ï¼šä¸å¯ç‚¹å‡»
  // status = 2ï¼ˆè¯­éŸ³åˆæˆæˆåŠŸï¼‰ï¼šä¸å¯ç‚¹å‡»
  // status = 3ï¼ˆè¯­éŸ³åˆæˆå¤±è´¥ï¼‰ï¼šå¯ç‚¹å‡»
  // status = 4ï¼ˆè¯­éŸ³åˆå¹¶ä¸­ï¼‰ï¼šä¸å¯ç‚¹å‡»ï¼ˆä½†ä¼šç›´æ¥è·³è½¬ï¼‰
  // status = 5ï¼ˆè¯­éŸ³åˆå¹¶æˆåŠŸï¼‰ï¼šä¸å¯ç‚¹å‡»
  // status = 6ï¼ˆè¯­éŸ³åˆå¹¶å¤±è´¥ï¼‰ï¼šå¯ç‚¹å‡»
  if (taskStatus.value === null) return true // åˆå§‹çŠ¶æ€ï¼Œé»˜è®¤å¯ç‚¹å‡»
  return taskStatus.value === 0 || taskStatus.value === 3 || taskStatus.value === 6
})

const canMergeAudio = computed(() => {
  // status = 0ï¼ˆæ‹†å¥å®Œæˆï¼‰ï¼šä¸å¯ç‚¹å‡»
  // status = 1ï¼ˆè¯­éŸ³åˆæˆä¸­ï¼‰ï¼šä¸å¯ç‚¹å‡»
  // status = 2ï¼ˆè¯­éŸ³åˆæˆæˆåŠŸï¼‰ï¼šå¯ç‚¹å‡»
  // status = 3ï¼ˆè¯­éŸ³åˆæˆå¤±è´¥ï¼‰ï¼šä¸å¯ç‚¹å‡»
  // status = 4ï¼ˆè¯­éŸ³åˆå¹¶ä¸­ï¼‰ï¼šä¸å¯ç‚¹å‡»ï¼ˆä½†ä¼šç›´æ¥è·³è½¬ï¼‰
  // status = 5ï¼ˆè¯­éŸ³åˆå¹¶æˆåŠŸï¼‰ï¼šä¸å¯ç‚¹å‡»
  // status = 6ï¼ˆè¯­éŸ³åˆå¹¶å¤±è´¥ï¼‰ï¼šå¯ç‚¹å‡»
  if (taskStatus.value === null) return false // åˆå§‹çŠ¶æ€ï¼Œé»˜è®¤ä¸å¯ç‚¹å‡»
  return taskStatus.value === 2 || taskStatus.value === 6
})

const handleMergeAudio = async () => {
  if (!taskId.value) {
    ElMessage.warning('ç¼ºå°‘ä»»åŠ¡ID')
    return
  }
  
  try {
    // è°ƒç”¨åˆå¹¶éŸ³é¢‘æ¥å£
    // mergeAudioTask æ˜¯ useSentencesRepository ä¸­çš„æ–¹æ³•ï¼Œå®ƒè°ƒç”¨ mergeAudio API
    // å“åº”æ‹¦æˆªå™¨è¿”å›çš„æ˜¯ res.dataï¼Œæ‰€ä»¥è¿”å›å€¼ç›´æ¥å°±æ˜¯ data å¯¹è±¡
    const mergeResult = await mergeAudioTask(taskId.value)
    
    console.log('ğŸ” [handleMergeAudio] åˆå¹¶éŸ³é¢‘æ¥å£è¿”å›', mergeResult)
    
    // ä»æ¥å£è¿”å›çš„æ•°æ®ä¸­è·å– mergeId
    // mergeResult å¯èƒ½æ˜¯ç›´æ¥çš„æ•°æ®å¯¹è±¡ï¼Œä¹Ÿå¯èƒ½æœ‰ data å±æ€§
    const data = mergeResult?.data !== undefined ? mergeResult.data : mergeResult
    const mergeId = data?.mergeId || data?.merge_id || taskMergeId.value
    
    console.log('ğŸ” [handleMergeAudio] æå–çš„ mergeId', {
      mergeResult,
      data,
      mergeId,
      taskMergeId: taskMergeId.value,
      mergeIdFromData: data?.mergeId,
      mergeIdFromDataSnake: data?.merge_id
    })
    
    // æ›´æ–° taskMergeId
    if (mergeId) {
      taskMergeId.value = mergeId
    }
    
    // è·³è½¬åˆ°åˆå¹¶éŸ³é¢‘è¿›åº¦é¡µé¢
    const query = {
      taskId: taskId.value || route.query.taskId
    }
    
    // å¦‚æœæœ‰ mergeIdï¼Œä¼ é€’ mergeId å‚æ•°
    if (mergeId) {
      query.mergeId = String(mergeId) // ç¡®ä¿æ˜¯å­—ç¬¦ä¸²ç±»å‹
    }
    
    console.log('ğŸ” [handleMergeAudio] è·³è½¬åˆ°åˆå¹¶éŸ³é¢‘è¿›åº¦é¡µé¢', query)
    router.push({
      name: 'MergeAudioProgress',
      query
    })
  } catch (error) {
    console.error('åˆå¹¶éŸ³é¢‘å¤±è´¥:', error)
    ElMessage.error('åˆå¹¶éŸ³é¢‘å¤±è´¥ï¼Œè¯·é‡è¯•')
  }
}

const setAudioRef = (sentenceId, el) => {
  if (el) {
    audioRefs.value[sentenceId] = el
  }
}

const cancelTooltipHide = () => {
  if (polyphonicTooltipTimer) {
    clearTimeout(polyphonicTooltipTimer)
    polyphonicTooltipTimer = null
  }
}

const hidePolyphonicTooltip = () => {
  cancelTooltipHide()
  polyphonicTooltip.visible = false
  polyphonicTooltip.markerId = ''
  polyphonicTooltip.sentenceId = null
  polyphonicTooltip.char = ''
  polyphonicTooltip.options = []
  polyphonicTooltip.selected = ''
  isTooltipHovering.value = false
}

const scheduleTooltipHide = () => {
  if (isTooltipHovering.value) return
  cancelTooltipHide()
  polyphonicTooltipTimer = setTimeout(() => {
    if (!isTooltipHovering.value) {
      hidePolyphonicTooltip()
    }
  }, 250)
}

const showPolyphonicTooltip = (marker, rect) => {
  cancelTooltipHide()
  isTooltipHovering.value = false
  const centerX = rect.left + (rect.right - rect.left) / 2
  const bottomY = rect.bottom + 8
  polyphonicTooltip.visible = true
  polyphonicTooltip.markerId = marker.id
  polyphonicTooltip.sentenceId = marker.sentenceId
  polyphonicTooltip.char = marker.char
  polyphonicTooltip.options = marker.options || []
  polyphonicTooltip.selected = marker.selected || ''
  polyphonicTooltip.position = {
    x: centerX,
    y: bottomY
  }
}

const handlePolyphonicHover = (sub, payload) => {
  if (!sub) return
  if (!payload) {
    scheduleTooltipHide()
    return
  }
  if (!payload.rect) {
    scheduleTooltipHide()
    return
  }
  const marker = getPolyphonicMarkers(sub).find(
    (item) => item.id === payload.markerId
  )
  if (!marker) {
    scheduleTooltipHide()
    return
  }
  const modeActive = isPolyphonicModeActive(sub)
  if (!modeActive && !marker.selected) {
    hidePolyphonicTooltip()
    return
  }
  showPolyphonicTooltip(marker, payload.rect)
}

const handleTooltipMouseEnter = () => {
  isTooltipHovering.value = true
  cancelTooltipHide()
}

const handleTooltipMouseLeave = () => {
  isTooltipHovering.value = false
  scheduleTooltipHide()
}

const handlePolyphonicOptionSelect = (option) => {
  const { sentenceId, markerId } = polyphonicTooltip
  if (!sentenceId || !markerId) return
  const state = ensurePolyphonicState(sentenceId)
  if (!state) return
  if (option) {
    state.selections[markerId] = option
  } else {
    delete state.selections[markerId]
  }
  const target = findSentenceById(sentenceId)
  refreshPolyphonicForSub(target)
  hidePolyphonicTooltip()
}

const togglePolyphonicMode = () => {
  const sub = currentSubSentence.value
  if (!sub) return
  const current = !!polyphonicModeMap[sub.sentence_id]
  polyphonicModeMap[sub.sentence_id] = !current
  refreshPolyphonicForSub(sub)
  if (!polyphonicModeMap[sub.sentence_id]) {
    hidePolyphonicTooltip()
  }
}

const insertPauseMarker = () => {
  const currentId = editingSubSentenceId.value
  if (!currentId) return
  const editor = editorRefs[currentId]
  if (editor?.insertPause) {
    editor.insertPause()
  }
}

const insertSilenceMarker = (duration) => {
  const currentId = editingSubSentenceId.value
  if (!currentId) return
  const editor = editorRefs[currentId]
  if (editor?.insertSilence) {
    editor.insertSilence(duration)
  }
}

const promptSilenceDuration = async () => {
  try {
    const { value } = await ElMessageBox.prompt('è¯·è¾“å…¥é™éŸ³æ—¶é•¿ï¼ˆç§’ï¼‰', 'æ’å…¥é™éŸ³', {
      confirmButtonText: 'ç¡®å®š',
      cancelButtonText: 'å–æ¶ˆ',
      inputPlaceholder: 'ä¾‹å¦‚ 3.1',
      inputValue: '1.0'
    })
    const parsed = Number(value)
    if (Number.isNaN(parsed) || parsed <= 0) {
      ElMessage.error('è¯·è¾“å…¥å¤§äº 0 çš„ç§’æ•°')
      return
    }
    const normalized = Math.min(60, Math.max(0.1, parsed))
    const formatted =
      normalized % 1 === 0 ? normalized.toString() : normalized.toFixed(1)
    insertSilenceMarker(formatted)
  } catch (error) {
    if (error !== 'cancel') {
      console.error('æ’å…¥é™éŸ³å¤±è´¥:', error)
    }
  }
}

const handleSplitStandard = () => {
  if (!editingSentenceId.value) {
    ElMessage.warning('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªå¥å­è¿›è¡Œç¼–è¾‘')
    return
  }

  const rootSentence = findSentenceById(editingSentenceId.value)
  if (!rootSentence) {
    ElMessage.error('æœªæ‰¾åˆ°å½“å‰å¥å­')
    return
  }

  // å­˜å‚¨ä¸Šä¸‹æ–‡
  splitStandardContext.value = {
    rootSentence,
    originalText: rootSentence.content || ''
  }

  // é‡ç½®é€‰æ‹©å€¼
  splitStandardType.value = 'punctuation'

  // æ˜¾ç¤ºå¯¹è¯æ¡†
  splitStandardDialogVisible.value = true
}

const handleSplitStandardDialogClose = () => {
  splitStandardDialogVisible.value = false
  splitStandardContext.value = null
  // é‡ç½®é€‰æ‹©å€¼
  splitStandardType.value = 'punctuation'
  splitStandardCharCount.value = 50
}

const handleSplitStandardConfirm = () => {
  if (!splitStandardContext.value) {
    splitStandardDialogVisible.value = false
    return
  }

  const { rootSentence, originalText } = splitStandardContext.value
  const selectedType = splitStandardType.value

  if (selectedType === 'punctuation') {
    // å¤§ç¬¦å·ï¼šæ¸…ç©ºæ‰€æœ‰è¾“å…¥æ–‡æœ¬ï¼Œå°†åŸå§‹æ‹†å¥ä½œä¸ºè¾“å…¥æ–‡æœ¬
    handleSplitByPunctuation(rootSentence, originalText)
    splitStandardDialogVisible.value = false
    splitStandardContext.value = null
  } else if (selectedType === 'charCount') {
    // å­—ç¬¦æ•°ï¼šä½¿ç”¨å¯¹è¯æ¡†ä¸­è¾“å…¥çš„å­—ç¬¦æ•°
    const charCount = parseInt(splitStandardCharCount.value, 10)
    if (Number.isNaN(charCount) || charCount <= 0) {
      ElMessage.error('è¯·è¾“å…¥å¤§äº 0 çš„å­—ç¬¦æ•°')
      return
    }
    handleSplitByCharCount(rootSentence, originalText, charCount)
    splitStandardDialogVisible.value = false
    splitStandardContext.value = null
  } else {
    ElMessage.warning('è¯·é€‰æ‹©æ–­å¥æ–¹å¼')
  }
}


const handleSplitByPunctuation = async (rootSentence, originalText) => {
  try {
    // ä½¿ç”¨æ§åˆ¶å™¨å¤„ç†æŒ‰æ ‡ç‚¹ç¬¦å·æ‹†åˆ†çš„æ•°æ®é€»è¾‘
    const newSentence = sentenceController.splitByPunctuation(rootSentence, originalText)

    if (newSentence && newSentence.sentence_id) {
      ensurePolyphonicState(newSentence.sentence_id)
      selectSubSentence(newSentence)
      ElMessage.success('å·²æŒ‰å¤§ç¬¦å·é‡ç½®ï¼šæ¸…ç©ºæ‰€æœ‰è¾“å…¥æ–‡æœ¬ï¼Œå¹¶å°†çˆ¶å¥å¤åˆ¶ä¸ºè¾“å…¥æ–‡æœ¬1')
    } else {
      ElMessage.error('åˆ›å»ºå­å¥å­å¤±è´¥')
    }
  } catch (error) {
    console.error('æŒ‰æ ‡ç‚¹ç¬¦å·æ‹†åˆ†å¤±è´¥:', error)
    ElMessage.error(error.message || 'æ‹†åˆ†å¤±è´¥')
  }
}

const handleSplitByCharCount = async (rootSentence, originalText, charCount) => {
  try {
    // ä½¿ç”¨æ§åˆ¶å™¨å¤„ç†æŒ‰å­—ç¬¦æ•°æ‹†åˆ†çš„æ•°æ®é€»è¾‘
    const newSentences = sentenceController.splitByCharCount(rootSentence, originalText, charCount)

    // å¤„ç†æ–°æ–­å¥çš„çŠ¶æ€
    newSentences.forEach(newSentence => {
      if (newSentence && newSentence.sentence_id) {
        ensurePolyphonicState(newSentence.sentence_id)
      }
    })

    // å¦‚æœå½“å‰é€‰ä¸­çš„æ˜¯çˆ¶å¥å­ï¼Œæ›´æ–°ç¼–è¾‘è¡¨å•ä¸ºæ‹†åˆ†åçš„ç¬¬ä¸€æ®µæ–‡æœ¬
    if (newSentences.length > 0 && editingSubSentenceId.value === rootSentence.sentence_id) {
      editingForm.content = newSentences[0].content
    }

    ElMessage.success(`å·²æŒ‰ ${charCount} ä¸ªå­—ç¬¦æ‹†åˆ†ä¸º ${newSentences.length} å¥`)
  } catch (error) {
    console.error('æŒ‰å­—ç¬¦æ•°æ‹†åˆ†å¤±è´¥:', error)
    ElMessage.error(error.message || 'æ‹†åˆ†å¤±è´¥')
  }
}

const handleCustomAction = (actionKey) => {
  if (actionKey === 'pause') {
    if (!isPauseEnabled.value) return
    insertPauseMarker()
  } else if (actionKey === 'polyphonic') {
    togglePolyphonicMode()
  } else if (actionKey === 'silence') {
    promptSilenceDuration()
  } else if (actionKey === 'split-standard') {
    handleSplitStandard()
  } else if (actionKey === 'reading-rules') {
    router.push('/reading-rules')
  }
}

const formatDuration = (seconds) => {
  if (!seconds) return ''
  const mins = Math.floor(seconds / 60)
  const secs = Math.floor(seconds % 60)
  return `${mins}:${secs.toString().padStart(2, '0')}`
}
</script>

<style scoped>
.sentences-page {
  padding: 20px 0 60px;
  display: flex;
  flex-direction: column;
  height: 100%;
  min-height: 0;
}

.page-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding: 0 20px;
}

.header-actions {
  display: flex;
  gap: 12px;
  align-items: center;
}

.page-header h2 {
  font-size: 22px;
  font-weight: 600;
}

.sentences-card {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  margin: 0 20px;
}

.sentences-card :deep(.el-card__body) {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  padding: 20px;
}

.empty-state {
  padding: 40px;
  text-align: center;
}

.sentence-list {
  display: flex;
  flex-direction: column;
  gap: 20px;
  flex: 1;
  min-height: 0;
  overflow-y: auto;
  padding-right: 8px;
}

.sentence-list::-webkit-scrollbar {
  width: 6px;
}

.sentence-list::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 3px;
}

.sentence-list::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 3px;
}

.sentence-list::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

.loading-more,
.no-more {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  padding: 20px;
  color: #999;
  font-size: 14px;
  margin-top: auto;
  margin-bottom: 0px;
}

.loading-more .el-icon {
  font-size: 16px;
}

.sentence-item {
  padding: 0;
}

.sentence-layout {
  display: flex;
  justify-content: space-between;
  gap: 24px;
  padding: 20px;
}

.sentence-main {
  flex: 1;
  min-width: 0;
  border: 1px solid #e4e7ed;
  border-radius: 6px;
  background: #fff;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.04);
  padding: 16px;
}

.sentence-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.sentence-number {
  font-weight: 600;
  color: #1d1f23;
  margin-right: 12px;
}

.sentence-duration {
  font-size: 12px;
  color: #999;
}

.sentence-status {
  font-size: 12px;
  color: #f56c6c;
}

.sentence-status.success {
  color: #67c23a;
}

.sentence-content {
  flex: 1;
  padding: 14px 16px;
  background: #f7f9fc;
  border-radius: 6px;
  line-height: 1.6;
  color: #333;
}

.sentence-text-row {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 16px;
}

.sentence-text {
  flex: 1;
  min-width: 0;
}

.sentence-links {
  display: flex;
  align-items: center;
  flex-shrink: 0;
  gap: 8px;
  white-space: nowrap;
  font-size: 13px;
  color: #5a7efc;
}

.sentence-link {
  cursor: pointer;
  color: #5a7efc;
}

.sentence-link.danger {
  color: #f56c6c;
}

.sentence-divider {
  color: #c0c4cc;
}

.sentence-status-tag {
  color: #f59a23;
  font-weight: 600;
}

.sentence-quick-actions {
  width: 80px;
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  justify-content: center;
  gap: 8px;
  color: #666;
  font-size: 13px;
}
.editing-panel {
  margin-top: 16px;
  padding: 18px;
  border: 1px solid #e4e7ed;
  border-radius: 6px;
  background: #fdfdfd;
}

.textarea-wrapper {
  margin-top: 16px;
}

.textarea-input {
  position: relative;
}

.textarea-input :deep(.el-textarea__inner) {
  padding-right: 240px;
}

.textarea-floating-links {
  position: absolute;
  top: 12px;
  right: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  color: #5a7efc;
  background: rgba(255, 255, 255, 0.9);
  padding: 4px 6px;
  border-radius: 6px;
}

.textarea-link {
  cursor: pointer;
  color: #5a7efc;
}

.textarea-link.danger {
  color: #f56c6c;
}

.textarea-status-tag.pending {
  color: #f59a23;
  font-weight: 600;
}

.textarea-divider {
  color: #c0c4cc;
}

.textarea-toolbar {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
  color: #666;
}

.toolbar-links {
  display: flex;
  align-items: center;
  gap: 8px;
}

.textarea-count {
  color: #999;
  font-size: 12px;
}

.textarea-actions {
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 10px;
  flex-wrap: wrap;
  gap: 10px;
}

.link-group {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}

.textarea-buttons {
  display: flex;
  gap: 10px;
}

.merge-footer {
  margin-top: 20px;
  display: flex;
  justify-content: center;
  gap: 12px;
}

.local-speed-dialog__body {
  padding: 8px 4px;
}

.local-speed-dialog__info {
  margin-bottom: 10px;
  color: #666;
  font-size: 13px;
}

.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.25s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

.synthesis-progress-dialog :deep(.el-dialog__header) {
  padding: 20px 20px 10px;
}

.synthesis-progress-dialog :deep(.el-dialog__body) {
  padding: 20px;
}

.progress-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #1d1f23;
}

.progress-content {
  padding: 10px 0;
}

.progress-info {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.progress-text {
  display: flex;
  justify-content: space-between;
  font-size: 14px;
  color: #666;
}

.progress-status {
  text-align: center;
  font-size: 14px;
  color: #666;
}

.progress-status .success {
  color: #67c23a;
  font-weight: 600;
}

.progress-status .error {
  color: #f56c6c;
  font-weight: 600;
}
</style>

